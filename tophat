#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
// #include <esp32-hal-ledc.h> 

// ===================== ç”¨æˆ·é…ç½®åŒº =====================
#define INVERT_M1_ENCODER false
#define INVERT_M2_ENCODER true   // å³è½®åæ¥ä¿®æ­£

const char *ssid = "ESP32_PID_Control";
const char *password = "12345678";

// ===================== å‚æ•°è°ƒè¯•åŒº =====================
// å·¦ç”µæœº (M1) PID
float Kp1 = 3.0, Ki1 = 0.0, Kd1 = 0.1;
// å³ç”µæœº (M2) PID
float Kp2 = 2.93, Ki2 = 0.0, Kd2 = 0.1;

// é»˜è®¤å·¡èˆªé€Ÿåº¦
const float CRUISE_SPEED = 50.0;

// *** å…³é”®å‚æ•°ï¼šåŸåœ°æ—‹è½¬ 90 åº¦æ‰€éœ€çš„æ—¶é—´ (æ¯«ç§’) ***
// ä¿®æ­£è®°å½•ï¼šåŸ 1000ms å¯¼è‡´è¿‡å†²çº¦ 7 åº¦ã€‚
// ä¿®æ­£è®¡ç®—ï¼š1000 * (90/97) â‰ˆ 927msã€‚å–æ•´ä¸º 920msã€‚
// è¯·æ ¹æ®å®é™…åœ°é¢æ‘©æ“¦åŠ›å¾®è°ƒæ­¤å€¼ï¼
const int TURN_90_DURATION_MS = 965; 

// ===================== å…¨å±€å‚æ•° =====================
const float COUNTS_PER_REV = 4480.0;
const int PWM_FREQ = 20000;
const int PWM_RES = 8;
const int SAMPLE_TIME_MS = 100; 

volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;

// åŠ¨ä½œè®¡æ—¶å™¨
unsigned long action_start_time = 0;
bool is_turning_90 = false;

float current_rpm1 = 0;
float current_rpm2 = 0;
int pwm1 = 0;
int pwm2 = 0;

// ===================== PID ç±»å®šä¹‰ =====================
class SimplePID {
  public:
    float kp, ki, kd;
    float integral = 0;
    float prev_error = 0;
    
    SimplePID(float p, float i, float d) : kp(p), ki(i), kd(d) {}

    int compute(float target, float current, float dt) {
      float error = target - current;
      integral += error * dt;
      integral = constrain(integral, -255.0, 255.0); 
      float derivative = (error - prev_error) / dt;
      prev_error = error;
      float output = (kp * error) + (ki * integral) + (kd * derivative);
      return (int)constrain(output, -255, 255);
    }
    
    void reset() {
      integral = 0;
      prev_error = 0;
    }
};

SimplePID pid1(Kp1, Ki1, Kd1);
SimplePID pid2(Kp2, Ki2, Kd2);

// ===================== ç”µæœºå®šä¹‰ =====================
const int M1_ENCODER_A_PIN = 5;
const int M1_ENCODER_B_PIN = 4;
const int M1_RPWM_PIN = 7;
const int M1_LPWM_PIN = 6;
volatile long M1_duration = 0;
volatile int M1_encoder0PinALast = LOW;

const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 19;
const int M2_RPWM_PIN = 0;
const int M2_LPWM_PIN = 1;
volatile long M2_duration = 0;
volatile int M2_encoder0PinALast = LOW;

WebServer server(80);

// ===================== ç½‘é¡µä»£ç  =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <title>ESP32 Robot Control</title>
  <style>
    body { font-family: Arial; text-align: center; margin:0px auto; padding: 10px; background: #f4f4f4;}
    .card { background: white; max-width: 600px; margin: 0 auto; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 10px; }
    button { padding: 15px 25px; margin: 5px; cursor: pointer; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; }
    .btn-stop { background: #dc3545; color: white; width: 100%; margin-top: 10px;}
    .btn-dir { background: #007bff; color: white; width: 40%; }
    .btn-turn90 { background: #6f42c1; color: white; width: 40%; font-size: 16px; }
    .grid-container { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; justify-items: center; margin-bottom: 20px; }
    .data-row { display: flex; justify-content: space-between; align-items: center; margin: 5px 0; padding: 5px; background: #eee; border-radius: 5px;}
  </style>
</head>
<body>
  <div class="card">
    <h2>ğŸ® æœºå™¨äººæ–¹å‘æ§åˆ¶</h2>
    
    <div class="grid-container">
      <div class="grid-item"><button class="btn-turn90" onclick="turn90('L')">â†º 90Â°</button></div>
      <div class="grid-item"><button class="btn-dir" onclick="move('F')">â¬†ï¸</button></div>
      <div class="grid-item"><button class="btn-turn90" onclick="turn90('R')">â†» 90Â°</button></div>
      
      <div class="grid-item"><button class="btn-dir" onclick="move('L')">â¬…ï¸</button></div>
      <div class="grid-item"><button class="btn-stop" onclick="move('S')" style="width: 80px; padding: 15px 0;">ğŸ›‘</button></div>
      <div class="grid-item"><button class="btn-dir" onclick="move('R')">â¡ï¸</button></div>
      
      <div class="grid-item"></div>
      <div class="grid-item"><button class="btn-dir" onclick="move('B')">â¬‡ï¸</button></div>
      <div class="grid-item"></div>
    </div>

    <h3>å®æ—¶ç›‘æ§ (RPM)</h3>
    <div class="data-row" style="color:#d32f2f"><b>M1 (å·¦): <span id="rpm1">0</span></b></div>
    <div class="data-row" style="color:#1976d2"><b>M2 (å³): <span id="rpm2">0</span></b></div>
  </div>

<script>
  function move(dir) { fetch("/move?dir=" + dir); }
  function turn90(dir) { fetch("/turn90?dir=" + dir); }

  setInterval(function() {
    fetch("/data").then(response => response.json()).then(json => {
      document.getElementById("rpm1").innerText = json.m1.toFixed(1);
      document.getElementById("rpm2").innerText = json.m2.toFixed(1);
    });
  }, 200);
</script>
</body>
</html>
)rawliteral";

// ===================== ä¸­æ–­æœåŠ¡ =====================
void IRAM_ATTR wheelSpeed_M1() {
  int Lstate = digitalRead(M1_ENCODER_A_PIN);
  if(Lstate != M1_encoder0PinALast) {
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M1_ENCODER) dir = !dir;
    if(dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = Lstate;
}

void IRAM_ATTR wheelSpeed_M2() {
  int Lstate = digitalRead(M2_ENCODER_A_PIN);
  if(Lstate != M2_encoder0PinALast) {
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M2_ENCODER) dir = !dir;
    if(dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = Lstate;
}

// ===================== é©±åŠ¨é€»è¾‘ =====================
void set_motor_pwm(int rpwm_pin, int lpwm_pin, int pwm_val) {
  if (pwm_val > 0) {
    ledcWrite(lpwm_pin, 0);          
    ledcWrite(rpwm_pin, pwm_val); 
  } else {
    ledcWrite(lpwm_pin, abs(pwm_val));          
    ledcWrite(rpwm_pin, 0); 
  }
}

// ===================== Web Handlers =====================
void handleRoot() { server.send(200, "text/html", index_html); }

void handleMove() {
  if (server.hasArg("dir")) {
    String dir = server.arg("dir");
    pid1.reset(); pid2.reset();
    is_turning_90 = false; 

    if (dir == "F") {      
      target_rpm_m1 = CRUISE_SPEED; target_rpm_m2 = CRUISE_SPEED;
    } else if (dir == "B") { 
      target_rpm_m1 = -CRUISE_SPEED; target_rpm_m2 = -CRUISE_SPEED;
    } else if (dir == "L") { 
      target_rpm_m1 = -CRUISE_SPEED; target_rpm_m2 = CRUISE_SPEED;
    } else if (dir == "R") { 
      target_rpm_m1 = CRUISE_SPEED; target_rpm_m2 = -CRUISE_SPEED;
    } else if (dir == "S") { 
      target_rpm_m1 = 0; target_rpm_m2 = 0;
    }
    server.send(200, "text/plain", "OK");
  }
}

void handleTurn90() {
  if (server.hasArg("dir")) {
    String dir = server.arg("dir");
    pid1.reset(); pid2.reset();
    
    if (dir == "L") {
      target_rpm_m1 = -CRUISE_SPEED;
      target_rpm_m2 = CRUISE_SPEED;
    } else { // R
      target_rpm_m1 = CRUISE_SPEED;
      target_rpm_m2 = -CRUISE_SPEED;
    }
    
    is_turning_90 = true;
    action_start_time = millis();
    
    server.send(200, "text/plain", "Turning 90");
  }
}

void handleData() {
  String json = "{\"m1\":" + String(current_rpm1) + ",\"m2\":" + String(current_rpm2) + "}";
  server.send(200, "application/json", json);
}

// ===================== Setup & Loop =====================
void setup() {
  Serial.begin(115200);
  WiFi.softAP(ssid, password);
  Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());

  server.on("/", handleRoot);
  server.on("/move", handleMove);
  server.on("/turn90", handleTurn90); 
  server.on("/data", handleData);
  server.begin();

  pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP); 
  pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);

  ledcAttach(M1_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M1_LPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_LPWM_PIN, PWM_FREQ, PWM_RES);
}

void loop() {
  server.handleClient();

  static unsigned long last_time = 0;
  unsigned long now = millis();
  
  if (is_turning_90) {
    // ä¿®æ­£ï¼šå‡å°‘æ—¶é—´ä»¥è¡¥å¿æƒ¯æ€§ (ä» 1000ms æ”¹ä¸º 920ms)
    if (now - action_start_time >= TURN_90_DURATION_MS) {
      target_rpm_m1 = 0;
      target_rpm_m2 = 0;
      is_turning_90 = false;
      
      // å¼ºåˆ¶åˆ¹è½¦ï¼šç«‹å³è¾“å‡º 0 PWM
      set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, 0);
      set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, 0);
      
      // é‡ç½® PID ç§¯åˆ†é¡¹ï¼Œé˜²æ­¢åˆ¹è½¦ååˆè •åŠ¨
      pid1.reset();
      pid2.reset();
      
      Serial.println("Turn 90 Complete (Braking)");
    }
  }
  
  if (now - last_time >= SAMPLE_TIME_MS) {
    float dt = (now - last_time) / 1000.0; 
    
    noInterrupts();
    long p1 = M1_duration; M1_duration = 0;
    long p2 = M2_duration; M2_duration = 0;
    interrupts();

    current_rpm1 = (p1 / COUNTS_PER_REV) * 60.0 / dt;
    current_rpm2 = (p2 / COUNTS_PER_REV) * 60.0 / dt;

    if (abs(target_rpm_m1) > 0.1) pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt);
    else pwm1 = 0;

    if (abs(target_rpm_m2) > 0.1) pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt);
    else pwm2 = 0;

    set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
    set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);

    last_time = now;
  }
}
