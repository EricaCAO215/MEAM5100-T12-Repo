//ESP32-C3 I2C Master Code
//test code writes and receives

//满血是0x64
#include <Wire.h>

#define I2C_SLAVE_ADDR 0x28
#define SDA_PIN 43
#define SCL_PIN 44
// 定义 I2C 通信周期为 500ms (2 Hz)
#define COMM_INTERVAL_MS 500 

// 全局变量
volatile int run_flag = 1;
unsigned long previousMillis = 0; // 用于 millis() 计时

void stop_all_motors() {
    Serial.println("ROBOT MOVEMENT DISABLED."); 
}

void send_I2C_byte(uint8_t data) {
    Wire.beginTransmission(I2C_SLAVE_ADDR);
    Wire.write(data);
    uint8_t error = Wire.endTransmission();

    if (error == 0) {
        Serial.printf("[%lu ms] SUCCESS: Data sent.\n", millis());
    } else {
        Serial.printf("[%lu ms] ERROR %d: Failed to send data to Top Hat (No ACK).\n", millis(), error);
    }
}

uint8_t receive_I2C_byte() {
    uint8_t bytesReceived = Wire.requestFrom(I2C_SLAVE_ADDR, 1);
    uint8_t current_health_hp = 0;

    if (bytesReceived > 0) {
        while (Wire.available()) {
            current_health_hp = Wire.read();
        }
        Serial.printf("Received HP: 0x%02X (%d HP) ", current_health_hp, current_health_hp);
        
        // --- 核心运行逻辑: 更新 run_flag ---
        if (current_health_hp == 0x00) { // 检查是否为 0 HP
            if (run_flag != 0) {
                Serial.println("-> STATUS: DEAD");
            }
            run_flag = 0; // 没血了，不能运行
            stop_all_motors();
        } else {
            if (run_flag != 1) {
                Serial.println("-> STATUS: ALIVE");
            }
            run_flag = 1; // 有血，可以运行
        }
        // --- 运行逻辑结束 ---

    } else {
        Serial.println("WARNING: Failed to receive health status (0 bytes received).");
        return 0;
    }
    return current_health_hp;
}

void setup() {
    Serial.begin(115200);
    // 使用 40kHz 低速，确保连接可靠
    Wire.begin(SDA_PIN, SCL_PIN, 40000); 
    Serial.println("----------------------------------------");
    Serial.println("ESP32-C3 I2C Master initialized (2 Hz).");
    Serial.printf("SDA: %d, SCL: %d\n", SDA_PIN, SCL_PIN);
    Serial.println("----------------------------------------");
}

void loop() {
    unsigned long currentMillis = millis();

    // 检查是否达到 500 毫秒的通信间隔 (2 Hz)
    if (currentMillis - previousMillis >= COMM_INTERVAL_MS) {
        previousMillis = currentMillis;

        // 1. 发送数据 (这里应是 WiFi 包数)
        // 替换 0x0 为实际的 WiFi 包数统计
        send_I2C_byte(0x1);
        
        // 2. 接收 HP 并更新 run_flag
        receive_I2C_byte();

        // 3. 打印当前的运行标志 (每 500ms 刷新一次)
        Serial.printf("-> RUN_FLAG: %d\n", run_flag);
        Serial.println("----------------------------------------");
    }

    // 这里是您的非阻塞式电机控制、传感器读取等代码
    // 由于没有 delay，这些代码会以微控制器最快的速度运行
    
    // 例如：
    // if (run_flag == 1) {
    //     read_sensors();
    //     update_motor_speeds();
    // }
}


