

/*
 * Board: ESP32-S2 (Master) - Single Board Architecture
 * Role: Web Server, Sensor, PID, Motor Control
 */
#include <Wire.h>
#include <VL53L0X.h>
#include <HardwareSerial.h>
#include <WiFi.h>
#include <WebServer.h>

// ===================== 1. 全局定义和引脚 =====================
// I2C (ToF)
#define MY_SDA 8
#define MY_SCL 9

// US-100 超声波
const int US100_RX_PIN = 44;
const int US100_TX_PIN = 43;
HardwareSerial US100Serial(1);

// 【新电机和编码器引脚 - 来自您的输入】
#define INVERT_M1_ENCODER false // M1 编码器方向配置
#define INVERT_M2_ENCODER true  // M2 编码器方向配置

const int M1_ENCODER_A_PIN = 7;
const int M1_ENCODER_B_PIN = 3;
const int M1_RPWM_PIN = 33;
const int M1_LPWM_PIN = 38;

const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 14;
const int M2_RPWM_PIN = 6;
const int M2_LPWM_PIN = 5;

// ===================== 2. 变量与对象 =====================
VL53L0X tofSensor;
WebServer server(80);

// WiFi 配置 (不变)
const char* ssid = "ESP32_Robot_Master";
const char* password = "12345678";
IPAddress local_ip(192, 168, 10, 1);
IPAddress gateway(192, 168, 10, 1);
IPAddress subnet(255, 255, 255, 0);

// 数据存储
float val_front = 0.0;
float val_side = 0.0;
bool obs_front = false;

// PID 参数
float Kp1 = 3.0, Ki1 = 0.0, Kd1 = 0.1;
float Kp2 = 2.93, Ki2 = 0.0, Kd2 = 0.1;
const float MAX_SPEED_RPM = 60.0;
const float COUNTS_PER_REV = 4480.0; // 编码器 PPR

// 运动控制变量
volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;
float current_rpm1 = 0; 
float current_rpm2 = 0;
int pwm1 = 0; int pwm2 = 0;

// 编码器计时变量
volatile long M1_duration = 0;
volatile int M1_encoder0PinALast = LOW;
volatile long M2_duration = 0;
volatile int M2_encoder0PinALast = LOW;

// 传感器计时
unsigned long lastUS100Time = 0;
bool waitingForUS100 = false;
unsigned long last_PID_time = 0;
const int PID_INTERVAL_MS = 100;

// ===================== 3. PID 类 (移植自 C3) =====================
class SimplePID { 
  public: 
    float kp,ki,kd,integral=0,prev_error=0; 
    SimplePID(float p,float i,float d):kp(p),ki(i),kd(d){} 
    int compute(float t,float c,float dt){
      float e=t-c;
      integral+=e*dt;
      integral=constrain(integral,-255,255);
      float d_val=(e-prev_error)/dt;
      prev_error=e;
      return constrain(kp*e+ki*integral+kd*d_val,-255,255);
    } 
    void reset(){integral=0;prev_error=0;}
};
SimplePID pid1(Kp1,Ki1,Kd1); 
SimplePID pid2(Kp2,Ki2,Kd2);

// ===================== 4. 中断函数 (移植自 C3) =====================
void IRAM_ATTR wheelSpeed_M1(){
  int s = digitalRead(M1_ENCODER_A_PIN);
  if(s != M1_encoder0PinALast){
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != s); 
    if (INVERT_M1_ENCODER) dir = !dir; 
    if(dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = s;
}

void IRAM_ATTR wheelSpeed_M2(){
  int s = digitalRead(M2_ENCODER_A_PIN);
  if(s != M2_encoder0PinALast){
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != s); 
    if (INVERT_M2_ENCODER) dir = !dir; 
    if(dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = s;
}

void set_motor_pwm(int r,int l,int v){if(v>0){ledcWrite(l,0);ledcWrite(r,v);}else{ledcWrite(l,abs(v));ledcWrite(r,0);}}


// ===================== 5. Web Server 函数 =====================
// HTML 网页代码 (不变)
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta charset="utf-8">
<title>ROBA Master</title>
<style>
body { font-family: sans-serif; text-align: center; margin:0; background: #f4f4f4; color: #333; touch-action: none; }
h2 { margin: 15px 0; color: #444; }

.panel { display: flex; justify-content: center; gap: 15px; margin: 20px; }
.card { background: #fff; padding: 15px; border-radius: 12px; width: 45%; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.val { font-size: 2rem; font-weight: bold; color: #2c3e50; }
.lbl { font-size: 0.9rem; color: #7f8c8d; margin-bottom: 5px; }

.danger { border: 3px solid #e74c3c; background: #fadbd8; }
.safe { border: 3px solid #2ecc71; }

#joy-zone {
position: relative; width: 240px; height: 240px; margin: 20px auto;
background: #dde; border-radius: 50%; border: 4px solid #bbb;
box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
}
#joy-knob {
position: absolute; width: 80px; height: 80px; background: #3498db;
border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);
box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.rpm { font-family: monospace; font-size: 1.2rem; margin-top: 20px; color: #555; }
</style>
</head>
<body>
<h2>ROBA Master Control</h2>

<div class="panel">
<div id="c-front" class="card safe">
<div class="lbl">FRONT (ToF)</div>
<div id="v-front" class="val">--</div>
</div>
<div id="c-side" class="card safe">
<div class="lbl">SIDE (US)</div>
<div id="v-side" class="val">--</div>
</div>
</div>

<div id="joy-zone"><div id="joy-knob"></div></div>

<div class="rpm">
L: <span id="r1">0</span> | R: <span id="r2">0</span>
</div>

<script>
var zone = document.getElementById("joy-zone");
var knob = document.getElementById("joy-knob");
var maxR = 80;
var rect, cx, cy, drag=false, lastT=0;

function setRect(){ rect=zone.getBoundingClientRect(); cx=rect.width/2; cy=rect.height/2; }
setRect(); window.onresize=setRect;

function start(e){ drag=true; e.preventDefault(); }
function end(){ drag=false; knob.style.transform="translate(-50%,-50%)"; send(0,0); }
function move(e){
if(!drag)return; e.preventDefault();
var tx=e.touches?e.touches[0].clientX:e.clientX;
var ty=e.touches?e.touches[0].clientY:e.clientY;
var x=tx-rect.left-cx; var y=ty-rect.top-cy;
var d=Math.sqrt(x*x+y*y);
if(d>maxR){ var a=Math.atan2(y,x); x=Math.cos(a)*maxR; y=Math.sin(a)*maxR; }
knob.style.transform=`translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;

if(Date.now()-lastT>100){
send(Math.round(x/maxR*100), Math.round(y/maxR*-100));
lastT=Date.now();
}
}

zone.addEventListener("mousedown",start); zone.addEventListener("touchstart",start);
document.addEventListener("mousemove",move); document.addEventListener("touchmove",move);
document.addEventListener("mouseup",end); document.addEventListener("touchend",end);

function send(x,y){ fetch("/joy?x="+x+"&y="+y); }

setInterval(()=>{
fetch("/data").then(r=>r.json()).then(d=>{
document.getElementById("v-front").innerText = d.f.toFixed(1);
document.getElementById("v-side").innerText = d.s.toFixed(1);
document.getElementById("r1").innerText = d.m1.toFixed(1);
document.getElementById("r2").innerText = d.m2.toFixed(1);

document.getElementById("c-front").className = d.f < 20.0 ? "card danger" : "card safe";
document.getElementById("c-side").className = d.s < 16.0 ? "card danger" : "card safe";
});
}, 200);
</script>
</body>
</html>
)rawliteral";

void handleRoot(){server.send(200,"text/html",index_html);}

// 【摇杆处理：直接计算目标 RPM】
void handleJoy(){
    if(server.hasArg("x")){
        int x=server.arg("x").toInt();
        int y=server.arg("y").toInt();
        
        // 避障：前方有障碍 & 想前进 -> 禁止
        if(obs_front && y > 0) y = 0;

        // 【新逻辑】计算目标 RPM
        float left = (float)y + (float)x;
        float right = (float)y - (float)x;
        float m = max(abs(left), abs(right));
        if(m > 100) { left = left/m*100; right = right/m*100; }
        
        target_rpm_m1 = (left / 100.0) * MAX_SPEED_RPM;
        target_rpm_m2 = (right / 100.0) * MAX_SPEED_RPM;

        if (x==0 && y==0) { pid1.reset(); pid2.reset(); }
        
        server.send(200,"text/plain","OK");
    }
}

void handleData(){
    String json="{";
    json+="\"f\":"+String(val_front)+",";
    json+="\"s\":"+String(val_side)+",";
    json+="\"m1\":"+String(current_rpm1, 1)+","; // 发送实际 RPM
    json+="\"m2\":"+String(current_rpm2, 1);     // 发送实际 RPM
    json+="}";
    server.send(200,"application/json",json);
}

// 【删除】parseC3Feedback() 函数已被移除


// ===================== 6. Setup & Loop =====================

void setup() {
    Serial.begin(115200);

    // 1. 电机和编码器引脚配置
    pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP); pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
    pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP); pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
    attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);
    
    // PWM 引脚绑定
    ledcAttach(M1_RPWM_PIN, 20000, 8); ledcAttach(M1_LPWM_PIN, 20000, 8);
    ledcAttach(M2_RPWM_PIN, 20000, 8); ledcAttach(M2_LPWM_PIN, 20000, 8);

    // 2. WiFi AP
    WiFi.softAPConfig(local_ip, gateway, subnet);
    WiFi.softAP(ssid, password);
    server.on("/", handleRoot);
    server.on("/joy", handleJoy);
    server.on("/data", handleData);
    server.begin();

    // 3. 初始化 ToF
    Wire.begin(MY_SDA, MY_SCL);
    tofSensor.init();
    tofSensor.setTimeout(500);
    tofSensor.setSignalRateLimit(0.1);
    tofSensor.setMeasurementTimingBudget(50000);
    tofSensor.setVcselPulsePeriod(VL53L0X::VcselPeriodPreRange, 18);
    tofSensor.setVcselPulsePeriod(VL53L0X::VcselPeriodFinalRange, 14);

    // 4. 初始化 US-100
    US100Serial.begin(9600, SERIAL_8N1, US100_RX_PIN, US100_TX_PIN);
}

void loop() {
    server.handleClient();
    
    // ================== PID 控制循环 (每 100ms) ==================
    if (millis() - last_PID_time >= PID_INTERVAL_MS) {
        float dt = (millis() - last_PID_time) / 1000.0;
        
        // 1. 读取编码器和计算 RPM
        noInterrupts(); 
        long p1=M1_duration; M1_duration=0; 
        long p2=M2_duration; M2_duration=0; 
        interrupts();
        
        current_rpm1 = (p1 / COUNTS_PER_REV) * 60.0 / dt;
        current_rpm2 = (p2 / COUNTS_PER_REV) * 60.0 / dt;
        
        // 2. 计算 PWM
        if (abs(target_rpm_m1) > 0.1) pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt); else pwm1 = 0;
        if (abs(target_rpm_m2) > 0.1) pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt); else pwm2 = 0;

        // 3. 设置电机 PWM
        set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
        set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);
        
        last_PID_time = millis();
    }
    // ==========================================================

    unsigned long now = millis();

    // --- ToF ---
    uint16_t mm = tofSensor.readRangeSingleMillimeters();
    if (!tofSensor.timeoutOccurred()) val_front = mm / 10.0;
    else val_front = -1.0;
    
    obs_front = (val_front > 0 && val_front < 20.0);

    // --- US-100 ---
    if (!waitingForUS100 && (now - lastUS100Time >= 100)) {
        while (US100Serial.available()) US100Serial.read();
        US100Serial.write(0x55);
        lastUS100Time = now;
        waitingForUS100 = true;
    }

    if (waitingForUS100) {
        if (US100Serial.available() >= 2) {
            unsigned int h = US100Serial.read();
            unsigned int l = US100Serial.read();
            unsigned int dist = (h * 256) + l;
            if (dist > 0 && dist < 4500) val_side = dist / 10.0;
            waitingForUS100 = false;
        }
        if (now - lastUS100Time > 50) waitingForUS100 = false;
    }
}
