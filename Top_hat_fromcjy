#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <Wire.h>
#include "vive510.h"
#include <math.h>

// ===================== Áî®Êà∑ÈÖçÁΩÆÂå∫ =====================
#define INVERT_M1_ENCODER false
#define INVERT_M2_ENCODER true   // Âè≥ËΩÆÂèçÊé•‰øÆÊ≠£

const char *ssid     = "ESP32_Joystick_Car";
const char *password = "12345678";

// ===================== I2C (TopHat) =====================
#define I2C_SLAVE_ADDR      0x28
#define SDA_PIN             43
#define SCL_PIN             44
#define COMM_INTERVAL_MS    500   // 2Hz

volatile int run_flag = 1;
unsigned long last_i2c_ms = 0;

// ÁªüËÆ°‚ÄúÁΩëÈ°µÈÄö‰ø°‰ΩøÁî®‚Äù (Áî® HTTP request Ê¨°Êï∞Ëøë‰ºº)
volatile uint32_t http_window = 0;
volatile uint32_t http_total  = 0;

// ===================== PID ÂèÇÊï∞ =====================
float Kp1 = 3.0,  Ki1 = 0.0, Kd1 = 0.1;
float Kp2 = 2.93, Ki2 = 0.0, Kd2 = 0.1;

// ÊúÄÂ§ßÈÄüÂ∫¶ÈôêÂà∂ (RPM)
const float MAX_SPEED_RPM = 80.0;

// ===================== ÁºñÁ†ÅÂô® / Êó∂Èó¥ÂèÇÊï∞ =====================
const float COUNTS_PER_REV = 4480.0;
const int PWM_FREQ = 20000;
const int PWM_RES  = 8;
const int SAMPLE_TIME_MS = 100;

volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;

float current_rpm1 = 0;
float current_rpm2 = 0;
int pwm1 = 0;
int pwm2 = 0;

// ===================== ÁÆÄÂçï PID Á±ª =====================
class SimplePID {
  public:
    float kp, ki, kd;
    float integral = 0;
    float prev_error = 0;

    SimplePID(float p, float i, float d) : kp(p), ki(i), kd(d) {}

    int compute(float target, float current, float dt) {
      float error = target - current;
      integral += error * dt;
      integral = constrain(integral, -255.0, 255.0);
      float derivative = (error - prev_error) / dt;
      prev_error = error;
      float output = (kp * error) + (ki * integral) + (kd * derivative);
      return (int)constrain(output, -255, 255);
    }

    void reset() {
      integral = 0;
      prev_error = 0;
    }
};

SimplePID pid1(Kp1, Ki1, Kd1);
SimplePID pid2(Kp2, Ki2, Kd2);

// ===================== ÁîµÊú∫‰∏éÁºñÁ†ÅÂô®ÂÆö‰πâ =====================
const int M1_ENCODER_A_PIN = 7;
const int M1_ENCODER_B_PIN = 3;
const int M1_RPWM_PIN      = 33;
const int M1_LPWM_PIN      = 38;
volatile long M1_duration  = 0;
volatile int  M1_encoder0PinALast = LOW;

const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 14;
const int M2_RPWM_PIN      = 6;
const int M2_LPWM_PIN      = 5;
volatile long M2_duration  = 0;
volatile int  M2_encoder0PinALast = LOW;

WebServer server(80);

// ===================== Vive ÂÆö‰πâÔºàÂçï Vive + Êª§Ê≥¢Ôºâ =====================
#define SIGNALPIN 12
Vive510 vive(SIGNALPIN);

uint16_t vive_x = 0, vive_y = 0;
bool vive_valid = false;

const int   WINDOW_SIZE = 5;
const float OUTLIER_THRESHOLD = 500.0f;

class MedianFilter {
  public:
    uint16_t history[WINDOW_SIZE];
    int head = 0;
    int count = 0;

    MedianFilter() {
      for (int i=0;i<WINDOW_SIZE;i++) history[i] = 0;
    }

    void add(uint16_t v) {
      history[head] = v;
      head = (head + 1) % WINDOW_SIZE;
      if (count < WINDOW_SIZE) count++;
    }

    uint16_t median() {
      if (count == 0) return 0;
      uint16_t tmp[WINDOW_SIZE];
      for (int i=0;i<count;i++) tmp[i] = history[i];
      for (int i=0;i<count-1;i++) {
        for (int j=i+1;j<count;j++) {
          if (tmp[j] < tmp[i]) {
            uint16_t t = tmp[i]; tmp[i]=tmp[j]; tmp[j]=t;
          }
        }
      }
      return tmp[count/2];
    }
};

MedianFilter filterX;
MedianFilter filterY;

bool filterViveValue(uint16_t val, MedianFilter &f) {
  if (f.count < 3) {
    f.add(val);
    return true;
  }
  uint16_t med = f.median();
  if (abs((long)val - (long)med) > OUTLIER_THRESHOLD) return false;
  f.add(val);
  return true;
}

// Êú∫Âô®‰∫∫‰ΩçÂßø‰º∞ËÆ°
float robot_rx = 0.0f, robot_ry = 0.0f;
float robot_theta_deg = 0.0f;
bool  robot_pose_valid = false;

float headingRad = 0.0f;
bool heading_initialized = false;
float last_rx = 0.0f, last_ry = 0.0f;

// ===================== Go-To / Waypoints =====================
float target_x = 0.0f, target_y = 0.0f;
bool goto_active = false;

const float GOTO_DIST_EPS   = 50.0f;
const float GOTO_SLOW_DIST  = 400.0f;
const float MIN_GOTO_SPEED  = 25.0f;
const float KW              = 2.0f;

const int   MAX_WP = 3;
float wp_x[MAX_WP];
float wp_y[MAX_WP];
int   wp_count = 0;
int   wp_idx   = 0;
bool  wp_active = false;

// ===================== ÁΩëÈ°µ (Âè™Áî®‰Ω†Èïø‰ª£Á†ÅÁöÑËÆæËÆ°) =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta charset="utf-8">
  <title>ESP32 Joystick</title>
  <style>
    body { font-family: 'Microsoft YaHei', Arial, sans-serif; text-align: center; margin:0; padding:0; background: #ffffff; color: #333; overflow: hidden; touch-action: none;}
    h2 { margin: 15px 0; font-size: 1.4rem; color: #444; }

    #joystick-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 10px auto;
      background: #f0f0f0;
      border-radius: 50%;
      border: 2px solid #ccc;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
    }

    #joystick-knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: #007bff;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      cursor: pointer;
    }

    .data-box { display: flex; justify-content: space-around; margin-top: 10px; font-size: 0.9rem; flex-wrap: wrap; }
    .val { font-weight: bold; font-family: monospace; font-size: 1.0rem; }
    .lbl-l { color: #d32f2f; }
    .lbl-r { color: #1976d2; }

    .goto-box { margin-top: 10px; font-size: 0.9rem; }
    .goto-box input { width: 70px; padding: 4px; margin: 2px; }
    .goto-box button { padding: 5px 10px; margin: 2px; border: none; border-radius: 4px; background: #007bff; color: white; font-size: 0.9rem; }

    .wp-box { margin-top: 10px; font-size: 0.9rem; }
    .wp-box input { width: 70px; padding: 4px; margin: 2px; }
    .wp-box button { padding: 5px 10px; margin: 2px; border: none; border-radius: 4px; background: #444; color: white; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h2>üïπÔ∏è ËôöÊãüÊëáÊùÜÊéßÂà∂ + Vive ÂØºËà™</h2>

  <div id="joystick-container">
    <div id="joystick-knob"></div>
  </div>

  <div class="data-box">
    <div class="lbl-l">Â∑¶ËΩÆ RPM: <span id="rpm1" class="val">0</span></div>
    <div class="lbl-r">Âè≥ËΩÆ RPM: <span id="rpm2" class="val">0</span></div>
  </div>

  <div class="data-box">
    <div>Vive: (<span id="v1x" class="val">0</span>, <span id="v1y" class="val">0</span>)</div>
  </div>

  <div class="data-box">
    <div>Pose: X=<span id="rx" class="val">0</span>,
         Y=<span id="ry" class="val">0</span>,
         Œ∏=<span id="th" class="val">0</span>¬∞</div>
  </div>

  <div class="goto-box">
    <span>Go to (X,Y):</span>
    <input id="tx" type="number" placeholder="X">
    <input id="ty" type="number" placeholder="Y">
    <button onclick="sendGoto()">Go</button>
    <button onclick="sendStop()">Stop</button>
  </div>

  <div class="wp-box">
    <div style="margin-bottom:4px;">Waypoints (ÊúÄÂ§ö 3 ‰∏™ÔºåÈ°∫Â∫èÊâßË°å)Ôºö</div>
    <div>
      <input id="w1x" type="number" placeholder="X1">
      <input id="w1y" type="number" placeholder="Y1">
    </div>
    <div>
      <input id="w2x" type="number" placeholder="X2">
      <input id="w2y" type="number" placeholder="Y2">
    </div>
    <div>
      <input id="w3x" type="number" placeholder="X3">
      <input id="w3y" type="number" placeholder="Y3">
    </div>
    <button onclick="sendWaypoints()">Start Waypoints</button>
    <button onclick="clearWaypoints()">Clear Waypoints</button>
  </div>

  <p style="color:#888; font-size:0.8rem; margin-top: 8px;">
    ÊëáÊùÜÔºöÊâãÂä®ÊéßÂà∂„ÄÇGoÔºöÂçïÁÇπÂØºËà™„ÄÇWaypointsÔºöÂ§öÁÇπÈ°∫Â∫èÂØºËà™„ÄÇ
  </p>

<script>
  var container = document.getElementById("joystick-container");
  var knob      = document.getElementById("joystick-knob");

  var maxRadius = 70;

  var rect = container.getBoundingClientRect();
  var centerX = rect.width / 2;
  var centerY = rect.height / 2;
  var isDragging = false;
  var lastSendTime = 0;

  knob.addEventListener("mousedown", startDrag);
  knob.addEventListener("touchstart", startDrag);
  document.addEventListener("mousemove", moveDrag);
  document.addEventListener("touchmove", moveDrag);
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);

  function startDrag(e) { isDragging = true; e.preventDefault(); }

  function moveDrag(e) {
    if (!isDragging) return;
    e.preventDefault();

    var clientX = e.touches ? e.touches[0].clientX : e.clientX;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;

    rect = container.getBoundingClientRect();
    var x = clientX - rect.left - centerX;
    var y = clientY - rect.top  - centerY;

    var distance = Math.sqrt(x*x + y*y);
    if (distance > maxRadius) {
      var angle = Math.atan2(y, x);
      x = Math.cos(angle) * maxRadius;
      y = Math.sin(angle) * maxRadius;
    }

    knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;

    var now = Date.now();
    if (now - lastSendTime > 100) {
      var normX = Math.round((x / maxRadius) * 100);
      var normY = Math.round((y / maxRadius) * -100);
      sendJoystick(normX, normY);
      lastSendTime = now;
    }
  }

  function endDrag() {
    isDragging = false;
    knob.style.transform = "translate(-50%, -50%)";
    sendJoystick(0, 0);
  }

  function sendJoystick(x, y) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/joystick?x=" + x + "&y=" + y, true);
    xhr.send();
  }

  function sendGoto() {
    var tx = document.getElementById("tx").value;
    var ty = document.getElementById("ty").value;
    if (tx === "" || ty === "") return;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/goto?x=" + tx + "&y=" + ty, true);
    xhr.send();
  }

  function sendStop() {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/stop", true);
    xhr.send();
  }

  function sendWaypoints() {
    var w = [];
    function addPair(ix, iy) {
      var x = document.getElementById(ix).value;
      var y = document.getElementById(iy).value;
      if (x !== "" && y !== "") w.push(x + "," + y);
    }
    addPair("w1x","w1y");
    addPair("w2x","w2y");
    addPair("w3x","w3y");
    if (w.length === 0) return;

    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/waypoints?pts=" + encodeURIComponent(w.join(";")), true);
    xhr.send();
  }

  function clearWaypoints() {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/clearwp", true);
    xhr.send();
  }

  setInterval(function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        var json = JSON.parse(this.responseText);
        document.getElementById("rpm1").innerHTML = json.m1.toFixed(1);
        document.getElementById("rpm2").innerHTML = json.m2.toFixed(1);
        document.getElementById("v1x").innerHTML = json.v1x;
        document.getElementById("v1y").innerHTML = json.v1y;
        document.getElementById("rx").innerHTML  = json.rx.toFixed(1);
        document.getElementById("ry").innerHTML  = json.ry.toFixed(1);
        document.getElementById("th").innerHTML  = json.th.toFixed(1);
      }
    };
    xhr.open("GET", "/data", true);
    xhr.send();
  }, 200);
</script>
</body>
</html>
)rawliteral";

// ===================== Utils =====================
static inline void count_http() { http_total++; http_window++; }

static inline void hardStopNow() {
  goto_active = false;
  wp_active = false;
  target_rpm_m1 = 0.0f;
  target_rpm_m2 = 0.0f;
  pid1.reset();
  pid2.reset();
  ledcWrite(M1_LPWM_PIN, 0);
  ledcWrite(M1_RPWM_PIN, 0);
  ledcWrite(M2_LPWM_PIN, 0);
  ledcWrite(M2_RPWM_PIN, 0);
}

static inline void startSingleGoto(float x, float y) {
  wp_active = false;
  wp_count = 0;
  wp_idx = 0;
  target_x = x;
  target_y = y;
  goto_active = true;
}

static inline void startWaypointRun() {
  if (wp_count <= 0) return;
  wp_idx = 0;
  wp_active = true;
  target_x = wp_x[0];
  target_y = wp_y[0];
  goto_active = true;
}

static inline void advanceWaypoint() {
  wp_idx++;
  if (wp_idx >= wp_count) {
    hardStopNow();
    Serial.println("WAYPOINTS: All done -> STOP.");
    return;
  }
  target_x = wp_x[wp_idx];
  target_y = wp_y[wp_idx];
  goto_active = true;
  Serial.print("WAYPOINTS: Next -> (");
  Serial.print(target_x);
  Serial.print(", ");
  Serial.print(target_y);
  Serial.println(")");
}

// ===================== I2C =====================
void stop_all_motors() { hardStopNow(); Serial.println("ROBOT MOVEMENT DISABLED."); }

void send_I2C_byte(uint8_t data) {
  Wire.beginTransmission(I2C_SLAVE_ADDR);
  Wire.write(data);
  uint8_t error = Wire.endTransmission();

  if (error == 0) {
    Serial.printf("[%lu ms] I2C TX OK: 0x%02X (%u)\n", millis(), data, data);
  } else {
    Serial.printf("[%lu ms] I2C TX ERROR %d (No ACK)\n", millis(), error);
    run_flag = 0;
    stop_all_motors();
  }
}

uint8_t receive_I2C_byte() {
  Wire.requestFrom(I2C_SLAVE_ADDR, (uint8_t)1);

  if (Wire.available() < 1) {
    Serial.printf("[%lu ms] I2C RX FAIL (0 bytes) -> FAILSAFE STOP\n", millis());
    run_flag = 0;
    stop_all_motors();
    return 0;
  }

  uint8_t hp = Wire.read();
  Serial.printf("Received HP: 0x%02X (%d HP) ", hp, hp);

  if (hp == 0x00) {
    if (run_flag != 0) Serial.println("-> STATUS: DEAD");
    run_flag = 0;
    stop_all_motors();
  } else {
    if (run_flag != 1) Serial.println("-> STATUS: ALIVE");
    run_flag = 1;
  }
  return hp;
}

// ===================== ÁºñÁ†ÅÂô®‰∏≠Êñ≠ =====================
void IRAM_ATTR wheelSpeed_M1() {
  int Lstate = digitalRead(M1_ENCODER_A_PIN);
  if (Lstate != M1_encoder0PinALast) {
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M1_ENCODER) dir = !dir;
    if (dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = Lstate;
}

void IRAM_ATTR wheelSpeed_M2() {
  int Lstate = digitalRead(M2_ENCODER_A_PIN);
  if (Lstate != M2_encoder0PinALast) {
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M2_ENCODER) dir = !dir;
    if (dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = Lstate;
}

// ===================== ÁîµÊú∫È©±Âä® =====================
void set_motor_pwm(int rpwm_pin, int lpwm_pin, int pwm_val) {
  if (pwm_val > 0) {
    ledcWrite(lpwm_pin, 0);
    ledcWrite(rpwm_pin, pwm_val);
  } else {
    ledcWrite(lpwm_pin, abs(pwm_val));
    ledcWrite(rpwm_pin, 0);
  }
}

// ===================== Vive Êõ¥Êñ∞ÔºàÂ∏¶Êª§Ê≥¢Ôºâ =====================
void updateVive() {
  if (vive.status() == VIVE_RECEIVING) {
    uint16_t x_raw = vive.xCoord();
    uint16_t y_raw = vive.yCoord();

    bool range_ok = (x_raw > 1000 && x_raw < 8000 &&
                     y_raw > 1000 && y_raw < 8000);

    if (range_ok) {
      bool okx = filterViveValue(x_raw, filterX);
      bool oky = filterViveValue(y_raw, filterY);
      if (okx && oky) {
        vive_x = filterX.median();
        vive_y = filterY.median();
        vive_valid = true;
      }
    } else {
      vive_valid = false;
    }
  } else {
    vive_valid = false;
    vive.sync(5);
  }
}

// ===================== Web Handlers =====================
void handleRoot() {
  count_http();
  server.send(200, "text/html; charset=utf-8", index_html);
}

void handleJoystick() {
  count_http();
  if (run_flag == 0) { hardStopNow(); server.send(200, "text/plain", "DEAD"); return; }

  if (server.hasArg("x") && server.hasArg("y")) {
    int x = server.arg("x").toInt();
    int y = server.arg("y").toInt();

    goto_active = false;
    wp_active = false;

    float left  = y + x;
    float right = y - x;

    float maxVal = max(abs(left), abs(right));
    if (maxVal > 100) {
      left  = (left  / maxVal) * 100;
      right = (right / maxVal) * 100;
    }

    target_rpm_m1 = (left  / 100.0f) * MAX_SPEED_RPM;
    target_rpm_m2 = (right / 100.0f) * MAX_SPEED_RPM;

    if (x == 0 && y == 0) { pid1.reset(); pid2.reset(); }
    server.send(200, "text/plain", "OK");
  } else {
    server.send(400, "text/plain", "Missing x/y");
  }
}

void handleGoto() {
  count_http();
  if (run_flag == 0) { hardStopNow(); server.send(200, "text/plain", "DEAD"); return; }

  if (server.hasArg("x") && server.hasArg("y")) {
    float x = server.arg("x").toFloat();
    float y = server.arg("y").toFloat();
    startSingleGoto(x, y);
    Serial.print("GOTO SET -> (");
    Serial.print(target_x);
    Serial.print(", ");
    Serial.print(target_y);
    Serial.println(")");
    server.send(200, "text/plain", "GOTO SET");
  } else {
    server.send(400, "text/plain", "Missing x/y");
  }
}

void handleStop() {
  count_http();
  hardStopNow();
  Serial.println("STOP by user.");
  server.send(200, "text/plain", "STOP");
}

void handleWaypoints() {
  count_http();
  if (run_flag == 0) { hardStopNow(); server.send(200, "text/plain", "DEAD"); return; }

  if (!server.hasArg("pts")) { server.send(400, "text/plain", "Missing pts"); return; }

  String pts = server.arg("pts");
  pts.trim();
  if (pts.length() == 0) { server.send(400, "text/plain", "Empty pts"); return; }

  wp_count = 0;
  wp_idx = 0;
  wp_active = false;

  int start = 0;
  while (wp_count < MAX_WP) {
    int sep = pts.indexOf(';', start);
    String one = (sep >= 0) ? pts.substring(start, sep) : pts.substring(start);
    one.trim();
    if (one.length() > 0) {
      int comma = one.indexOf(',');
      if (comma > 0) {
        float x = one.substring(0, comma).toFloat();
        float y = one.substring(comma + 1).toFloat();
        wp_x[wp_count] = x;
        wp_y[wp_count] = y;
        wp_count++;
      }
    }
    if (sep < 0) break;
    start = sep + 1;
  }

  if (wp_count <= 0) { server.send(400, "text/plain", "No valid waypoints"); return; }

  startWaypointRun();

  Serial.print("WAYPOINTS SET count=");
  Serial.print(wp_count);
  Serial.print(" start=(");
  Serial.print(target_x);
  Serial.print(", ");
  Serial.print(target_y);
  Serial.println(")");

  server.send(200, "text/plain", "WAYPOINTS START");
}

void handleClearWP() {
  count_http();
  wp_count = 0;
  wp_idx = 0;
  wp_active = false;
  server.send(200, "text/plain", "WAYPOINTS CLEARED");
}

void handleData() {
  count_http();
  String json = "{";
  json += "\"m1\":"  + String(current_rpm1);
  json += ",\"m2\":" + String(current_rpm2);
  json += ",\"v1x\":" + String(vive_x);
  json += ",\"v1y\":" + String(vive_y);
  json += ",\"rx\":"  + String(robot_rx, 1);
  json += ",\"ry\":"  + String(robot_ry, 1);
  json += ",\"th\":"  + String(robot_theta_deg, 1);
  json += ",\"valid\":" + String(robot_pose_valid ? 1 : 0);
  json += "}";
  server.send(200, "application/json", json);
}

void handleNotFound() {
  count_http();
  server.send(404, "text/plain", "404");
}

// ===================== Setup =====================
void setup() {
  Serial.begin(115200);
  delay(100);

  // WiFi AP
  WiFi.softAP(ssid, password);
  Serial.print("AP IP: ");
  Serial.println(WiFi.softAPIP());

  // Web routes
  server.on("/",          handleRoot);
  server.on("/joystick",  handleJoystick);
  server.on("/data",      handleData);
  server.on("/goto",      handleGoto);
  server.on("/stop",      handleStop);
  server.on("/waypoints", handleWaypoints);
  server.on("/clearwp",   handleClearWP);
  server.onNotFound(handleNotFound);
  server.begin();

  // I2C
  Wire.begin(SDA_PIN, SCL_PIN, 40000);
  Serial.printf("I2C SDA=%d SCL=%d SLAVE=0x%02X\n", SDA_PIN, SCL_PIN, I2C_SLAVE_ADDR);

  // Encoders
  pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);

  // PWM
  ledcAttach(M1_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M1_LPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_LPWM_PIN, PWM_FREQ, PWM_RES);

  // Vive
  vive.begin();

  Serial.println("------------------------------------");
  Serial.println("Vive + Web UI + Motors + I2C(2Hz) Init Done.");
  Serial.printf("Vive Pin: %d\n", SIGNALPIN);
  Serial.printf("Filter: window=%d, thr=%.1f\n", WINDOW_SIZE, OUTLIER_THRESHOLD);
  Serial.println("------------------------------------");
}

// ===================== Loop =====================
void loop() {
  server.handleClient();

  unsigned long now = millis();
  static unsigned long last_motor_time = 0;
  static unsigned long last_vive_time  = 0;

  // ---- I2C 2Hz: ÂèëÁΩëÈ°µ‚Äúpacket usage‚Äù(HTTPËØ∑Ê±ÇÊï∞) + Êî∂HP ----
  if (now - last_i2c_ms >= COMM_INTERVAL_MS) {
    last_i2c_ms = now;

    uint32_t pk = http_window;
    http_window = 0;
    uint8_t pk_byte = (pk > 255) ? 255 : (uint8_t)pk;

    Serial.printf("[%lu ms] HTTP(window)=%lu -> send 0x%02X\n", millis(), pk, pk_byte);
    send_I2C_byte(pk_byte);
    receive_I2C_byte();
    Serial.printf("-> RUN_FLAG: %d\n", run_flag);
    Serial.println("----------------------------------------");
  }

  // ---- Vive Êõ¥Êñ∞‰∏é‰ΩçÂßø‰º∞ËÆ° ----
  if (now - last_vive_time >= 50) {
    updateVive();

    if (vive_valid) {
      robot_rx = vive_x;
      robot_ry = vive_y;

      if (!heading_initialized) {
        last_rx = robot_rx;
        last_ry = robot_ry;
        heading_initialized = true;
      } else {
        float dx = robot_rx - last_rx;
        float dy = robot_ry - last_ry;
        float dist_move = sqrtf(dx*dx + dy*dy);
        if (dist_move > 3.0f) {
          float new_heading = atan2f(dy, dx);
          headingRad = 0.6f * headingRad + 0.4f * new_heading;
          last_rx = robot_rx;
          last_ry = robot_ry;
        }
      }

      robot_theta_deg = headingRad * 180.0f / PI;
      robot_pose_valid = true;
    } else {
      robot_pose_valid = false;
    }

    if (vive_valid) {
      Serial.print("Vive(FILT): (");
      Serial.print(vive_x);
      Serial.print(", ");
      Serial.print(vive_y);
      Serial.print(") | Pose: X=");
      Serial.print(robot_rx, 1);
      Serial.print(", Y=");
      Serial.print(robot_ry, 1);
      Serial.print(", Th=");
      Serial.print(robot_theta_deg, 1);
      Serial.println(" deg");
    } else {
      Serial.println("Vive: Invalid/Lost Tracking.");
    }

    last_vive_time = now;
  }

  // ---- DEAD: Âº∫Âà∂ÂÅú ----
  if (run_flag == 0) {
    hardStopNow();
  }

  // ---- GOTO / WAYPOINTS ----
  if (run_flag == 1 && goto_active && robot_pose_valid) {
    float dx = target_x - robot_rx;
    float dy = target_y - robot_ry;
    float dist = sqrtf(dx*dx + dy*dy);

    if (dist < GOTO_DIST_EPS) {
      if (wp_active) {
        Serial.println("WAYPOINTS: Reached one -> advance.");
        advanceWaypoint();
      } else {
        hardStopNow();
        Serial.println("GOTO: Target reached -> STOP.");
      }
    } else {
      float desired_heading = atan2f(dy, dx);
      float err = desired_heading - headingRad;
      while (err >  PI) err -= 2.0f * PI;
      while (err < -PI) err += 2.0f * PI;

      float v;
      if (dist > GOTO_SLOW_DIST) v = MAX_SPEED_RPM;
      else {
        float ratio = dist / GOTO_SLOW_DIST;
        v = MIN_GOTO_SPEED + (MAX_SPEED_RPM - MIN_GOTO_SPEED) * ratio;
      }

      float omega = KW * err * (MAX_SPEED_RPM / PI);
      float maxOmega = 0.7f * MAX_SPEED_RPM;
      if (omega >  maxOmega) omega =  maxOmega;
      if (omega < -maxOmega) omega = -maxOmega;

      float left_rpm  = v - omega;
      float right_rpm = v + omega;

      left_rpm  = constrain(left_rpm,  -MAX_SPEED_RPM, MAX_SPEED_RPM);
      right_rpm = constrain(right_rpm, -MAX_SPEED_RPM, MAX_SPEED_RPM);

      target_rpm_m1 = left_rpm;
      target_rpm_m2 = right_rpm;
    }
  }

  // ---- ÁîµÊú∫ PID ----
  if (now - last_motor_time >= (unsigned long)SAMPLE_TIME_MS) {
    float dt = (now - last_motor_time) / 1000.0f;

    noInterrupts();
    long p1 = M1_duration; M1_duration = 0;
    long p2 = M2_duration; M2_duration = 0;
    interrupts();

    current_rpm1 = (p1 / COUNTS_PER_REV) * 60.0f / dt;
    current_rpm2 = (p2 / COUNTS_PER_REV) * 60.0f / dt;

    if (run_flag == 1 && abs(target_rpm_m1) > 0.1f) pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt);
    else pwm1 = 0;

    if (run_flag == 1 && abs(target_rpm_m2) > 0.1f) pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt);
    else pwm2 = 0;

    set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
    set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);

    last_motor_time = now;
  }
}
