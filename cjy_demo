#include <WiFi.h>
#include <WebServer.h>
#include <esp32-hal-ledc.h>
#include <esp32-hal-adc.h>

// ================= Wi-Fi =================
const char* AP_SSID = "ESP32_PID_CHART_DUAL";
const char* AP_PASS = "123456789";
IPAddress AP_IP(192,168,4,1);

// ========== Pins / PWM (L298N) ==========
const int SPEED_PIN_L = 18;   // ENA
const int DIR_PIN_1   = 19;   // IN1
const int DIR_PIN_2   = 6;   // IN2  ← 修正为 G6
const int ENCODER_PIN_L = 1;  // 编码器 L

const int SPEED_PIN_R = 7;    // ENB
const int DIR_PIN_3   = 4;    // IN3
const int DIR_PIN_4   = 5;    // IN4
const int ENCODER_PIN_R = 0;  // 编码器 R

const int PWM_FREQ = 250;
const int PWM_BITS = 8;

// ========== PID ==========
float KP_L=3.0, KI_L=0.0, KD_L=0.1;
float KP_R=3.0, KI_R=0.0, KD_R=0.1;

float summederror_L=0, last_error_L=0;
float summederror_R=0, last_error_R=0;

const long PID_SAMPLE_TIME_MS = 50;
unsigned long last_pid_time = 0;

int   DesiredSpeed_Setpoint = 0;
float MeasuredVelocity_CountsPerSec_L = 0;
float MeasuredVelocity_CountsPerSec_R = 0;

float g_current_error_L=0; int g_current_pwm_output_L=0;
float g_current_error_R=0; int g_current_pwm_output_R=0;

// ====== 纯轮询的编码器变量（无中断）======
volatile long EncoderCounts_L = 0;
volatile long EncoderCounts_R = 0;
long last_counts_L = 0;
long last_counts_R = 0;

int  motorDirection_L = 0; // 0 停, ±1 表示方向，仅用于是否控制
int  motorDirection_R = 0;

int  prevL = HIGH, prevR = HIGH;      // 上一次电平
unsigned long lastEdgeUsL = 0, lastEdgeUsR = 0;
const unsigned long DEBOUNCE_US = 200; // 轻度消抖

// ========== Web ==========
WebServer server(80);

void handleRoot(); void handleForward(); void handleBackward();
void handleStop(); void handleSetSpeed(); void handleSetPID(); void handleGetData();

void setup() {
  Serial.begin(115200);

  // 电机引脚
  pinMode(DIR_PIN_1, OUTPUT);
  pinMode(DIR_PIN_2, OUTPUT);
  pinMode(SPEED_PIN_L, OUTPUT);

  pinMode(DIR_PIN_3, OUTPUT);
  pinMode(DIR_PIN_4, OUTPUT);
  pinMode(SPEED_PIN_R, OUTPUT);

  // 编码器输入（上拉，默认高）
  pinMode(ENCODER_PIN_L, INPUT_PULLUP);
  pinMode(ENCODER_PIN_R, INPUT_PULLUP);
  prevL = digitalRead(ENCODER_PIN_L);
  prevR = digitalRead(ENCODER_PIN_R);

  // PWM
  ledcAttach(SPEED_PIN_L, PWM_FREQ, PWM_BITS);
  ledcAttach(SPEED_PIN_R, PWM_FREQ, PWM_BITS);
  ledcWrite(SPEED_PIN_L, 0);
  ledcWrite(SPEED_PIN_R, 0);

  // 初始刹车
  digitalWrite(DIR_PIN_1, LOW);
  digitalWrite(DIR_PIN_2, LOW);
  digitalWrite(DIR_PIN_3, LOW);
  digitalWrite(DIR_PIN_4, LOW);

  // AP
  WiFi.softAPConfig(AP_IP, AP_IP, IPAddress(255,255,255,0));
  WiFi.softAP(AP_SSID, AP_PASS);
  Serial.println(WiFi.softAPIP());

  // 路由
  server.on("/", handleRoot);
  server.on("/forward", handleForward);
  server.on("/backward", handleBackward);
  server.on("/stop", handleStop);
  server.on("/setSpeed", handleSetSpeed);
  server.on("/setPID", handleSetPID);
  server.on("/getData", handleGetData);
  server.begin();

  last_pid_time = millis();
}

// ======== 轮询编码器：检测上升沿并计数 ========
inline void pollEncoders() {
  int curL = digitalRead(ENCODER_PIN_L);
  if (prevL == LOW && curL == HIGH) {           // 上升沿
    unsigned long now = micros();
    if (now - lastEdgeUsL > DEBOUNCE_US) {
      EncoderCounts_L++;                        // 只计数，不带符号
      lastEdgeUsL = now;
    }
  }
  prevL = curL;

  int curR = digitalRead(ENCODER_PIN_R);
  if (prevR == LOW && curR == HIGH) {
    unsigned long now = micros();
    if (now - lastEdgeUsR > DEBOUNCE_US) {
      EncoderCounts_R++;
      lastEdgeUsR = now;
    }
  }
  prevR = curR;
}

void loop() {
  server.handleClient();

  // 高频轮询编码器（尽量每次 loop 都跑）
  pollEncoders();

  // 每 50ms 做一次速度估计 + PID
  if (millis() - last_pid_time < PID_SAMPLE_TIME_MS) return;

  noInterrupts(); // 这里不再有中断，但为确保与 pollEncoders 的一致性可短暂关一次
  long current_counts_L = EncoderCounts_L;
  long current_counts_R = EncoderCounts_R;
  interrupts();

  long counts_delta_L = current_counts_L - last_counts_L; last_counts_L = current_counts_L;
  long counts_delta_R = current_counts_R - last_counts_R; last_counts_R = current_counts_R;

  MeasuredVelocity_CountsPerSec_L = (float)counts_delta_L * (1000.0 / PID_SAMPLE_TIME_MS);
  MeasuredVelocity_CountsPerSec_R = (float)counts_delta_R * (1000.0 / PID_SAMPLE_TIME_MS);

  int pwm_output_L = 0, pwm_output_R = 0;
  float LARGE_SUM = 2000.0;

  // 左轮
  if (motorDirection_L == 0) {
    pwm_output_L = 0; summederror_L = 0; last_error_L = 0; g_current_error_L = 0;
  } else {
    float error_L = DesiredSpeed_Setpoint - MeasuredVelocity_CountsPerSec_L;
    g_current_error_L = error_L;
    summederror_L += error_L;
    if (summederror_L >  LARGE_SUM) summederror_L =  LARGE_SUM;
    if (summederror_L < -LARGE_SUM) summederror_L = -LARGE_SUM;
    float dL = error_L - last_error_L; last_error_L = error_L;
    float outL = KP_L*error_L + KI_L*summederror_L + KD_L*dL;
    if (outL < 0) outL = 0; if (outL > 255) outL = 255;
    pwm_output_L = (int)outL;
  }

  // 右轮
  if (motorDirection_R == 0) {
    pwm_output_R = 0; summederror_R = 0; last_error_R = 0; g_current_error_R = 0;
  } else {
    float error_R = DesiredSpeed_Setpoint - MeasuredVelocity_CountsPerSec_R;
    g_current_error_R = error_R;
    summederror_R += error_R;
    if (summederror_R >  LARGE_SUM) summederror_R =  LARGE_SUM;
    if (summederror_R < -LARGE_SUM) summederror_R = -LARGE_SUM;
    float dR = error_R - last_error_R; last_error_R = error_R;
    float outR = KP_R*error_R + KI_R*summederror_R + KD_R*dR;
    if (outR < 0) outR = 0; if (outR > 255) outR = 255;
    pwm_output_R = (int)outR;
  }

  g_current_pwm_output_L = pwm_output_L;
  g_current_pwm_output_R = pwm_output_R;
  ledcWrite(SPEED_PIN_L, g_current_pwm_output_L);
  ledcWrite(SPEED_PIN_R, g_current_pwm_output_R);

  Serial.printf("L: T:%d M:%.1f E:%.1f P:%d | R: T:%d M:%.1f E:%.1f P:%d\n",
    DesiredSpeed_Setpoint, MeasuredVelocity_CountsPerSec_L, g_current_error_L, g_current_pwm_output_L,
    DesiredSpeed_Setpoint, MeasuredVelocity_CountsPerSec_R, g_current_error_R, g_current_pwm_output_R);

  last_pid_time = millis();
}

// ========== HTTP handlers（原样保留）==========
void handleRoot() { /* ……你原来的 HTML/JS …… */ server.send(200,"text/html",""); } // 这里省略：请用你现有的 handleRoot 内容
void handleForward(){
  digitalWrite(DIR_PIN_1, HIGH);  // IN1=1
  digitalWrite(DIR_PIN_2, LOW);   // IN2=0  → 正转
  digitalWrite(DIR_PIN_3, HIGH);
  digitalWrite(DIR_PIN_4, LOW);
  motorDirection_L = 1;
  motorDirection_R = 1;
  summederror_L = summederror_R = 0;
  last_error_L = last_error_R = 0;
  server.send(200,"text/plain","OK - Forward");
}
void handleBackward(){
  digitalWrite(DIR_PIN_1, LOW);   // IN1=0
  digitalWrite(DIR_PIN_2, HIGH);  // IN2=1  → 反转
  digitalWrite(DIR_PIN_3, LOW);
  digitalWrite(DIR_PIN_4, HIGH);
  motorDirection_L = -1;
  motorDirection_R = -1;
  summederror_L = summederror_R = 0;
  last_error_L = last_error_R = 0;
  server.send(200,"text/plain","OK - Backward");
}
void handleStop(){
  digitalWrite(DIR_PIN_1, LOW);
  digitalWrite(DIR_PIN_2, LOW);
  digitalWrite(DIR_PIN_3, LOW);
  digitalWrite(DIR_PIN_4, LOW);
  motorDirection_L = 0;
  motorDirection_R = 0;
  DesiredSpeed_Setpoint = 0;
  summederror_L = summederror_R = 0;
  last_error_L = last_error_R = 0;
  server.send(200,"text/plain","OK - Stopped");
}
void handleSetSpeed(){
  String s = server.arg("value");
  if (s!="") DesiredSpeed_Setpoint = s.toInt();
  server.send(200,"text/plain","OK");
}
void handleSetPID(){
  if (server.hasArg("kp_l")) KP_L = server.arg("kp_l").toFloat();
  if (server.hasArg("ki_l")) KI_L = server.arg("ki_l").toFloat();
  if (server.hasArg("kd_l")) KD_L = server.arg("kd_l").toFloat();
  if (server.hasArg("kp_r")) KP_R = server.arg("kp_r").toFloat();
  if (server.hasArg("ki_r")) KI_R = server.arg("ki_r").toFloat();
  if (server.hasArg("kd_r")) KD_R = server.arg("kd_r").toFloat();
  summederror_L = summederror_R = 0;
  last_error_L = last_error_R = 0;
  server.send(200,"text/plain","OK - PID Updated");
}
void handleGetData(){
  String json = "{";
  json += "\"target\":" + String(DesiredSpeed_Setpoint);
  json += ",\"measured_l\":" + String(MeasuredVelocity_CountsPerSec_L,1);
  json += ",\"error_l\":" + String(g_current_error_L,1);
  json += ",\"pwm_l\":" + String(g_current_pwm_output_L);
  json += ",\"measured_r\":" + String(MeasuredVelocity_CountsPerSec_R,1);
  json += ",\"error_r\":" + String(g_current_error_R,1);
  json += ",\"pwm_r\":" + String(g_current_pwm_output_R);
  json += "}";
  server.send(200,"application/json",json);
}
