
#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <math.h>   
#include "vive510.h"

// ===================== ç”¨æˆ·é…ç½®åŒº =====================
#define INVERT_M1_ENCODER false // M1 ç¼–ç å™¨æ–¹å‘é…ç½®
#define INVERT_M2_ENCODER true  // M2 ç¼–ç å™¨æ–¹å‘é…ç½®

const char *ssid = "ESP32_Joystick_Car"; // çƒ­ç‚¹åå­—
const char *password = "12345678";

// ===================== Vive è¿½è¸ªé…ç½® =====================
// Vive1 / Vive2 æ‰€åœ¨çš„ GPIO å¼•è„š
#define SIGNALPIN1 17   // ä¿æŒä¸å˜
#define SIGNALPIN2 0    // æ ¹æ®ç”¨æˆ·åé¦ˆï¼ŒVive2 ä½¿ç”¨ GPIO 0 

Vive510 vive1(SIGNALPIN1);
Vive510 vive2(SIGNALPIN2);

// Vive è¿½è¸ªæ•°æ® (é‡å‘½åä»¥é¿å… y1 å†²çª)
uint16_t vive_x1 = 0, vive_y1 = 0, vive_x2 = 0, vive_y2 = 0;
float thetaDeg = NAN;
bool valid1 = false, valid2 = false;

// ===================== PID å‚æ•° =====================
float Kp1 = 3.0, Ki1 = 0.0, Kd1 = 0.1;
float Kp2 = 2.93, Ki2 = 0.0, Kd2 = 0.1;

// æœ€å¤§é€Ÿåº¦é™åˆ¶ (RPM)
const float MAX_SPEED_RPM = 60.0;

// ===================== å…¨å±€å‚æ•° =====================
const float COUNTS_PER_REV = 4480.0;
const int PWM_FREQ = 20000;
const int PWM_RES = 8;
const int SAMPLE_TIME_MS = 100; 

volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;

float current_rpm1 = 0;
float current_rpm2 = 0;
int pwm1 = 0;
int pwm2 = 0;

// ===================== PID ç±»å®šä¹‰ (ä¿æŒä¸å˜) =====================
class SimplePID {
  public:
    float kp, ki, kd;
    float integral = 0;
    float prev_error = 0;
    
    SimplePID(float p, float i, float d) : kp(p), ki(i), kd(d) {}

    int compute(float target, float current, float dt) {
      float error = target - current;
      integral += error * dt;
      integral = constrain(integral, -255.0, 255.0); 
      float derivative = (error - prev_error) / dt;
      prev_error = error;
      float output = (kp * error) + (ki * integral) + (kd * derivative);
      return (int)constrain(output, -255, 255);
    }
    
    void reset() {
      integral = 0;
      prev_error = 0;
    }
};

SimplePID pid1(Kp1, Ki1, Kd1);
SimplePID pid2(Kp2, Ki2, Kd2);

// ===================== ç”µæœºå®šä¹‰ (æ ¹æ®ç”¨æˆ·æœ€æ–°é…ç½®ä¿®æ”¹) =====================
// M1
const int M1_ENCODER_A_PIN = 7;
const int M1_ENCODER_B_PIN = 3;
const int M1_RPWM_PIN = 33;
const int M1_LPWM_PIN = 38;
volatile long M1_duration = 0;
volatile int M1_encoder0PinALast = LOW;

// M2
const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 14;
const int M2_RPWM_PIN = 6;
const int M2_LPWM_PIN = 5; 
volatile long M2_duration = 0;
volatile int M2_encoder0PinALast = LOW;

WebServer server(80);

// ===================== ç½‘é¡µä»£ç  (ä¿æŒä¸å˜) =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta charset="utf-8">
  <title>ESP32 Joystick & Vive</title>
  <style>
    body { font-family: 'Microsoft YaHei', Arial, sans-serif; text-align: center; margin:0; padding:0; background: #ffffff; color: #333; overflow: hidden; touch-action: none;}
    h2 { margin: 15px 0; font-size: 1.4rem; color: #444; }
    
    #joystick-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px auto;
      background: #f0f0f0;
      border-radius: 50%;
      border: 2px solid #ccc;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
    }
    
    #joystick-knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: #007bff;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      cursor: pointer;
    }
    
    .data-box { 
      display: flex; 
      justify-content: space-around; 
      margin-top: 30px; 
      font-size: 1rem; 
      flex-wrap: wrap;
    }
    .val { font-weight: bold; font-family: monospace; font-size: 1.3rem; }
    
    .lbl-l { color: #d32f2f; }
    .lbl-r { color: #1976d2; }

    .vive-box { 
        margin: 10px 0; 
        width: 100%; 
        font-size: 1rem; 
        padding: 5px 0;
        border-top: 1px solid #eee;
    }
    .vive-coord { font-size: 0.9rem; color: #555; display: inline-block; width: 45%; }
    .vive-angle { font-size: 1.2rem; color: #007bff; margin-top: 5px; }
  </style>
</head>
<body>
  <h2>ğŸ•¹ï¸ è™šæ‹Ÿæ‘‡æ†æ§åˆ¶</h2>
  
  <div id="joystick-container">
    <div id="joystick-knob"></div>
  </div>

  <div class="data-box">
    <div class="lbl-l">å·¦è½® RPM: <span id="rpm1" class="val">0</span></div>
    <div class="lbl-r">å³è½® RPM: <span id="rpm2" class="val">0</span></div>
  </div>

  <div class="vive-box">
    <h3>ğŸ”­ Vive è¿½è¸ªæ•°æ®</h3>
    <div class="vive-coord">
      <span class="lbl-l">V1:</span> x=<span id="x1" class="val">0</span> y=<span id="y1" class="val">0</span>
    </div>
    <div class="vive-coord">
      <span class="lbl-r">V2:</span> x=<span id="x2" class="val">0</span> y=<span id="y2" class="val">0</span>
    </div>
    <div class="vive-angle">
      è§’åº¦ (&theta;): <span id="theta" class="val">NaN</span> deg
    </div>
  </div>
  <p style="color:#888; font-size:0.9rem; margin-top: 20px;">æ‹–åŠ¨è“çƒæ§åˆ¶æ–¹å‘ï¼Œæ¾æ‰‹åœæ­¢</p>

<script>
  var container = document.getElementById("joystick-container");
  var knob = document.getElementById("joystick-knob");
  
  var maxRadius = 70; 
  
  var rect = container.getBoundingClientRect();
  var centerX = rect.width / 2;
  var centerY = rect.height / 2;
  var isDragging = false;
  var lastSendTime = 0;

  knob.addEventListener("mousedown", startDrag);
  knob.addEventListener("touchstart", startDrag);
  document.addEventListener("mousemove", moveDrag);
  document.addEventListener("touchmove", moveDrag);
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);

  function startDrag(e) {
    isDragging = true;
    e.preventDefault();
  }

  function moveDrag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    var clientX = e.touches ? e.touches[0].clientX : e.clientX;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    rect = container.getBoundingClientRect();
    var x = clientX - rect.left - centerX;
    var y = clientY - rect.top - centerY;
    
    var distance = Math.sqrt(x*x + y*y);
    if (distance > maxRadius) {
      var angle = Math.atan2(y, x);
      x = Math.cos(angle) * maxRadius;
      y = Math.sin(angle) * maxRadius;
    }
    
    knob.style.transform = 'translate(calc(-50% + ' + x + 'px), calc(-50% + ' + y + 'px))';
    
    var now = Date.now();
    if (now - lastSendTime > 100) { 
      var normX = Math.round((x / maxRadius) * 100);
      var normY = Math.round((y / maxRadius) * -100); 
      sendJoystick(normX, normY);
      lastSendTime = now;
    }
  }

  function endDrag() {
    isDragging = false;
    knob.style.transform = "translate(-50%, -50%)"; 
    sendJoystick(0, 0); 
  }

  function sendJoystick(x, y) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/joystick?x=" + x + "&y=" + y, true);
    xhr.send();
  }

  // å®šæ—¶è¯·æ±‚æ•°æ®å¹¶æ›´æ–°ç•Œé¢
  setInterval(function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        var json = JSON.parse(this.responseText);
        
        // RPM æ•°æ®
        document.getElementById("rpm1").innerHTML = json.m1.toFixed(1);
        document.getElementById("rpm2").innerHTML = json.m2.toFixed(1);

        // Vive æ•°æ®
        document.getElementById("x1").innerHTML = json.x1;
        document.getElementById("y1").innerHTML = json.y1;
        document.getElementById("x2").innerHTML = json.x2;
        document.getElementById("y2").innerHTML = json.y2;
        
        if (json.theta === "NaN") {
            document.getElementById("theta").innerHTML = "NaN";
        } else {
            document.getElementById("theta").innerHTML = parseFloat(json.theta).toFixed(2);
        }
      }
    };
    xhr.open("GET", "/data", true);
    xhr.send();
  }, 200); 
</script>
</body>
</html>
)rawliteral";

// ===================== Vive æ•°æ®å¤„ç†å‡½æ•° (ä¿æŒä¸å˜) =====================

// ä¸‰ç‚¹ä¸­å€¼æ»¤æ³¢å‡½æ•°
uint32_t med3filt(uint32_t a, uint32_t b, uint32_t c) {
  uint32_t middle;
  if ((a <= b) && (a <= c))
    middle = (b <= c) ? b : c;
  else if ((b <= a) && (b <= c))
    middle = (a <= c) ? a : c;
  else
    middle = (a <= b) ? a : b;
  return middle;
}

// æ›´æ–° Vive æ•°æ®ï¼Œè¿›è¡Œæ»¤æ³¢å’Œè§’åº¦è®¡ç®—
void updateViveData() {
  // -------- Vive1 é€»è¾‘ --------
  if (vive1.status() == VIVE_RECEIVING) {
    static uint16_t x10, y10, oldx11, oldx12, oldy11, oldy12;
    oldx12 = oldx11; oldy12 = oldy11;
    oldx11 = x10;    oldy11 = y10;
    
    x10 = vive1.xCoord();
    y10 = vive1.yCoord();
    vive_x1 = med3filt(x10, oldx11, oldx12);
    vive_y1 = med3filt(y10, oldy11, oldy12);

    if (vive_x1 > 8000 || vive_y1 > 8000 || vive_x1 < 1000 || vive_y1 < 1000) {
      vive_x1 = 0; vive_y1 = 0;
      valid1 = false;
    } else {
      valid1 = true;
    }
  } else {
    vive_x1 = 0; vive_y1 = 0; 
    valid1 = false;
    vive1.sync(5); 
  }
  
  // -------- Vive2 é€»è¾‘ --------
  if (vive2.status() == VIVE_RECEIVING) {
    static uint16_t x20, y20, oldx21, oldx22, oldy21, oldy22;
    oldx22 = oldx21; oldy22 = oldy21;
    oldx21 = x20;    oldy21 = y20;
    
    x20 = vive2.xCoord();
    y20 = vive2.yCoord();
    vive_x2 = med3filt(x20, oldx21, oldx22);
    vive_y2 = med3filt(y20, oldy21, oldy22);

    if (vive_x2 > 8000 || vive_y2 > 8000 || vive_x2 < 1000 || vive_y2 < 1000) {
      vive_x2 = 0; vive_y2 = 0;
      valid2 = false;
    } else {
      valid2 = true;
    }
  } else {
    vive_x2 = 0; vive_y2 = 0; 
    valid2 = false;
    vive2.sync(5);
  }
  
  // ---------------- å°æŠ–åŠ¨å¿½ç•¥æ»¤æ³¢ ----------------
  const int THRESH = 150;
  static uint16_t fx1 = 0, fy1 = 0, fx2 = 0, fy2 = 0;
  static bool inited1 = false, inited2 = false;

  if (valid1 && vive_x1 != 0 && vive_y1 != 0) {
    if (!inited1) {
      fx1 = vive_x1; fy1 = vive_y1;
      inited1 = true;
    } else {
      if (abs((int)vive_x1 - (int)fx1) < THRESH) vive_x1 = fx1;
      else fx1 = vive_x1;

      if (abs((int)vive_y1 - (int)fy1) < THRESH) vive_y1 = fy1;
      else fy1 = vive_y1;
    }
  } 

  if (valid2 && vive_x2 != 0 && vive_y2 != 0) {
    if (!inited2) {
      fx2 = vive_x2; fy2 = vive_y2;
      inited2 = true;
    } else {
      if (abs((int)vive_x2 - (int)fx2) < THRESH) vive_x2 = fx2;
      else fx2 = vive_x2;

      if (abs((int)vive_y2 - (int)fy2) < THRESH) vive_y2 = fy2;
      else fy2 = vive_y2;
    }
  } 
  
  // ---------------- æŠ–åŠ¨æ»¤æ³¢ç»“æŸ ------------------------------------

  // -------- è®¡ç®—è§’åº¦ --------
  thetaDeg = NAN;
  if (valid1 && valid2 && vive_x1 != 0 && vive_y1 != 0 && vive_x2 != 0 && vive_y2 != 0) {
    int32_t dx = (int32_t)vive_x2 - (int32_t)vive_x1;
    int32_t dy = (int32_t)vive_y2 - (int32_t)vive_y1;
    if (dx != 0 || dy != 0) {
      float thetaRad = atan2((float)dy, (float)dx);
      thetaDeg = thetaRad * 180.0f / PI; 
    }
  }
}

// ===================== ä¸­æ–­æœåŠ¡ (ç”µæœºç¼–ç å™¨) (æ ¹æ®ç”¨æˆ·æœ€æ–°é…ç½®ä¿®æ”¹) =====================
void IRAM_ATTR wheelSpeed_M1() {
  int Lstate = digitalRead(M1_ENCODER_A_PIN);
  if(Lstate != M1_encoder0PinALast) {
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M1_ENCODER) dir = !dir;
    if(dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = Lstate;
}

void IRAM_ATTR wheelSpeed_M2() {
  int Lstate = digitalRead(M2_ENCODER_A_PIN);
  if(Lstate != M2_encoder0PinALast) {
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M2_ENCODER) dir = !dir;
    if(dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = Lstate;
}

// ===================== é©±åŠ¨é€»è¾‘ (ä¿æŒä¸å˜) =====================
void set_motor_pwm(int rpwm_pin, int lpwm_pin, int pwm_val) {
  if (pwm_val > 0) {
    ledcWrite(lpwm_pin, 0);     
    ledcWrite(rpwm_pin, pwm_val);  
  } else {
    ledcWrite(lpwm_pin, abs(pwm_val));      
    ledcWrite(rpwm_pin, 0);  
  }
}

// ===================== Web Handlers (ä¿æŒä¸å˜) =====================
void handleRoot() { 
  server.send(200, "text/html; charset=utf-8", index_html); 
}

void handleJoystick() {
  if (server.hasArg("x") && server.hasArg("y")) {
    int x = server.arg("x").toInt();  
    int y = server.arg("y").toInt();  
    
    float left = y + x;
    float right = y - x;

    float maxVal = max(abs(left), abs(right));
    if (maxVal > 100) {
      left = (left / maxVal) * 100;
      right = (right / maxVal) * 100;
    }

    target_rpm_m1 = (left / 100.0) * MAX_SPEED_RPM;
    target_rpm_m2 = (right / 100.0) * MAX_SPEED_RPM;

    if (x == 0 && y == 0) {
      pid1.reset();
      pid2.reset();
    }

    server.send(200, "text/plain", "OK");
  }
}

void handleData() {
  // ä¼ è¾“ RPM å’Œ Vive åæ ‡/è§’åº¦
  String json = "{\"m1\":" + String(current_rpm1, 1) + 
                ",\"m2\":" + String(current_rpm2, 1) + 
                ",\"x1\":" + String(vive_x1) + 
                ",\"y1\":" + String(vive_y1) +
                ",\"x2\":" + String(vive_x2) + 
                ",\"y2\":" + String(vive_y2) +
                ",\"theta\":" + (isnan(thetaDeg) ? "\"NaN\"" : String(thetaDeg, 2)) +
                "}";
  server.send(200, "application/json", json);
}

// ===================== Setup & Loop (æ ¹æ®ç”¨æˆ·æœ€æ–°é…ç½®ä¿®æ”¹) =====================
void setup() {
  Serial.begin(115200);
  
  // 1. WiFi AP åˆå§‹åŒ–
  WiFi.softAP(ssid, password);
  Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());

  // 2. WebServer åˆå§‹åŒ–
  server.on("/", handleRoot);
  server.on("/joystick", handleJoystick);  
  server.on("/data", handleData);
  server.begin();

  // 3. ç”µæœºç¼–ç å™¨å¼•è„šåˆå§‹åŒ– (M1/M2 å‡å·²æ›´æ–°)
  pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP);  
  pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);

  // 4. ç”µæœºç¼–ç å™¨ä¸­æ–­æŒ‚è½½
  attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);

  // 5. ç”µæœº PWM å¼•è„šåˆå§‹åŒ– (M1/M2 å‡å·²æ›´æ–°)
  ledcAttach(M1_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M1_LPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_LPWM_PIN, PWM_FREQ, PWM_RES);

  // 6. Vive è¿½è¸ªå™¨åˆå§‹åŒ– (SIGNALPIN2 ç°ä¸º 0)
  vive1.begin();
  vive2.begin();
  Serial.println("Two Vive trackers started");
}

void loop() {
  server.handleClient();
  
  // 1. Vive æ•°æ®æ›´æ–°
  updateViveData();

  // 2. ç”µæœº PID æ§åˆ¶å‘¨æœŸ
  static unsigned long last_time = 0;
  unsigned long now = millis();
  
  if (now - last_time >= SAMPLE_TIME_MS) {
    float dt = (now - last_time) / 1000.0;  // é‡‡æ ·æ—¶é—´ (ç§’)
    
    // ç‹¬å ç¼–ç å™¨è®¡æ•°
    noInterrupts();
    long p1 = M1_duration; M1_duration = 0;
    long p2 = M2_duration; M2_duration = 0;
    interrupts();

    // è®¡ç®—å½“å‰ RPM
    current_rpm1 = (p1 / COUNTS_PER_REV) * 60.0 / dt;
    current_rpm2 = (p2 / COUNTS_PER_REV) * 60.0 / dt;

    // PID è®¡ç®—
    if (abs(target_rpm_m1) > 0.1) pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt);
    else pwm1 = 0;

    if (abs(target_rpm_m2) > 0.1) pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt);
    else pwm2 = 0;

    // è®¾ç½® PWM
    set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
    set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);

    last_time = now;
  }
}
