#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include "vive510.h"
#include <math.h>     // atan2, PI

// ===================== ç”¨æˆ·é…ç½®åŒº =====================
#define INVERT_M1_ENCODER false
#define INVERT_M2_ENCODER true   // å³è½®åæ¥ä¿®æ­£

const char *ssid     = "ESP32_Joystick_Car";
const char *password = "12345678";

// ===================== PID å‚æ•° =====================
float Kp1 = 3.0,  Ki1 = 0.0, Kd1 = 0.1;
float Kp2 = 2.93, Ki2 = 0.0, Kd2 = 0.1;

// æœ€å¤§é€Ÿåº¦é™åˆ¶ (RPM)
const float MAX_SPEED_RPM = 80.0;

// ===================== ç¼–ç å™¨ / æ—¶é—´å‚æ•° =====================
const float COUNTS_PER_REV = 4480.0;
const int PWM_FREQ = 20000;
const int PWM_RES  = 8;
const int SAMPLE_TIME_MS = 100;

volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;

float current_rpm1 = 0;
float current_rpm2 = 0;
int pwm1 = 0;
int pwm2 = 0;

// ===================== ç®€å• PID ç±» =====================
class SimplePID {
  public:
    float kp, ki, kd;
    float integral = 0;
    float prev_error = 0;

    SimplePID(float p, float i, float d) : kp(p), ki(i), kd(d) {}

    int compute(float target, float current, float dt) {
      float error = target - current;
      integral += error * dt;
      integral = constrain(integral, -255.0, 255.0);
      float derivative = (error - prev_error) / dt;
      prev_error = error;
      float output = (kp * error) + (ki * integral) + (kd * derivative);
      return (int)constrain(output, -255, 255);
    }

    void reset() {
      integral = 0;
      prev_error = 0;
    }
};

SimplePID pid1(Kp1, Ki1, Kd1);
SimplePID pid2(Kp2, Ki2, Kd2);

// ===================== ç”µæœºä¸ç¼–ç å™¨å®šä¹‰ =====================
const int M1_ENCODER_A_PIN = 7;
const int M1_ENCODER_B_PIN = 3;
const int M1_RPWM_PIN      = 33;
const int M1_LPWM_PIN      = 38;
volatile long M1_duration  = 0;
volatile int  M1_encoder0PinALast = LOW;

const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 14;
const int M2_RPWM_PIN      = 6;
const int M2_LPWM_PIN      = 5;
volatile long M2_duration  = 0;
volatile int  M2_encoder0PinALast = LOW;

WebServer server(80);

// ===================== Vive å®šä¹‰ï¼ˆå• Vive + æ»¤æ³¢ï¼‰ =====================
#define SIGNALPIN 12   // Vive ä¿¡å·å¼•è„š

Vive510 vive(SIGNALPIN);

uint16_t vive_x = 0, vive_y = 0;
bool vive_valid = false;

// ---- ä¸­å€¼æ»¤æ³¢ + å¼‚å¸¸å€¼å‰”é™¤ ----
const int   WINDOW_SIZE = 5;
const float OUTLIER_THRESHOLD = 500.0f; // è¶…è¿‡è¿™ä¹ˆå¤šç®—è·³ç‚¹ï¼Œä¸¢å¼ƒ

class MedianFilter {
  public:
    uint16_t history[WINDOW_SIZE];
    int head = 0;
    int count = 0;

    MedianFilter() {
      for (int i=0;i<WINDOW_SIZE;i++) history[i] = 0;
    }

    void add(uint16_t v) {
      history[head] = v;
      head = (head + 1) % WINDOW_SIZE;
      if (count < WINDOW_SIZE) count++;
    }

    uint16_t median() {
      if (count == 0) return 0;
      uint16_t tmp[WINDOW_SIZE];
      for (int i=0;i<count;i++) tmp[i] = history[i];
      // ç®€å•å†’æ³¡/æ’å…¥æ’åºä¹Ÿè¡Œï¼Œè¿™é‡Œç”¨ä¸ªæœ€ç¬¨çš„
      for (int i=0;i<count-1;i++) {
        for (int j=i+1;j<count;j++) {
          if (tmp[j] < tmp[i]) {
            uint16_t t = tmp[i]; tmp[i]=tmp[j]; tmp[j]=t;
          }
        }
      }
      return tmp[count/2];
    }
};

MedianFilter filterX;
MedianFilter filterY;

bool filterViveValue(uint16_t val, MedianFilter &f) {
  if (f.count < 3) {  // å‰å‡ æ¬¡æ²¡å†å²ï¼Œç›´æ¥æ”¶
    f.add(val);
    return true;
  }
  uint16_t med = f.median();
  if (abs((long)val - (long)med) > OUTLIER_THRESHOLD) {
    // è·³å¤ªå¤šï¼Œå½“ä½œå¼‚å¸¸å€¼ï¼Œä¸¢å¼ƒè¿™æ¬¡
    return false;
  }
  f.add(val);
  return true;
}

// æœºå™¨äººä½å§¿ä¼°è®¡
float robot_rx = 0.0f, robot_ry = 0.0f;
float robot_theta_deg = 0.0f;
bool  robot_pose_valid = false;

float headingRad = 0.0f;
bool heading_initialized = false;
float last_rx = 0.0f, last_ry = 0.0f;

// ===================== Go-To ç›®æ ‡ç‚¹æ§åˆ¶ =====================
float target_x = 0.0f, target_y = 0.0f;
bool goto_active = false;

// è°ƒå¤§åœæ­¢é˜ˆå€¼ï¼Œè®©å®ƒçœŸçš„ä¼šåœä¸‹æ¥
const float GOTO_DIST_EPS   = 50.0f;   // Vive åæ ‡ç³»ä¸‹ï¼Œè·ç¦»å°äº 300 å°±ç®—åˆ°ç‚¹
const float GOTO_SLOW_DIST  = 400.0f;
const float MIN_GOTO_SPEED  = 25.0f;
const float KW              = 2.0f;

// ===================== ç½‘é¡µä»£ç  =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta charset="utf-8">
  <title>ESP32 Joystick</title>
  <style>
    body { font-family: 'Microsoft YaHei', Arial, sans-serif; text-align: center; margin:0; padding:0; background: #ffffff; color: #333; overflow: hidden; touch-action: none;}
    h2 { margin: 15px 0; font-size: 1.4rem; color: #444; }

    #joystick-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 10px auto;
      background: #f0f0f0;
      border-radius: 50%;
      border: 2px solid #ccc;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
    }

    #joystick-knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: #007bff;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      cursor: pointer;
    }

    .data-box { display: flex; justify-content: space-around; margin-top: 10px; font-size: 0.9rem; flex-wrap: wrap; }
    .val { font-weight: bold; font-family: monospace; font-size: 1.0rem; }
    .lbl-l { color: #d32f2f; }
    .lbl-r { color: #1976d2; }

    .goto-box {
      margin-top: 10px;
      font-size: 0.9rem;
    }
    .goto-box input {
      width: 70px;
      padding: 4px;
      margin: 2px;
    }
    .goto-box button {
      padding: 5px 10px;
      margin: 2px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <h2>ğŸ•¹ï¸ è™šæ‹Ÿæ‘‡æ†æ§åˆ¶ + Vive å¯¼èˆª</h2>

  <div id="joystick-container">
    <div id="joystick-knob"></div>
  </div>

  <div class="data-box">
    <div class="lbl-l">å·¦è½® RPM: <span id="rpm1" class="val">0</span></div>
    <div class="lbl-r">å³è½® RPM: <span id="rpm2" class="val">0</span></div>
  </div>

  <div class="data-box">
    <div>Vive: (<span id="v1x" class="val">0</span>, <span id="v1y" class="val">0</span>)</div>
  </div>

  <div class="data-box">
    <div>Pose: X=<span id="rx" class="val">0</span>,
         Y=<span id="ry" class="val">0</span>,
         Î¸=<span id="th" class="val">0</span>Â°</div>
  </div>

  <div class="goto-box">
    <span>Go to (X,Y):</span>
    <input id="tx" type="number" placeholder="X">
    <input id="ty" type="number" placeholder="Y">
    <button onclick="sendGoto()">Go</button>
    <button onclick="sendStop()">Stop</button>
  </div>

  <p style="color:#888; font-size:0.8rem; margin-top: 8px;">
    æ‘‡æ†ï¼šæ‰‹åŠ¨æ§åˆ¶ã€‚Goï¼šè¾“å…¥ç›®æ ‡ Vive åæ ‡è‡ªåŠ¨å¯¼èˆªã€‚
  </p>

<script>
  var container = document.getElementById("joystick-container");
  var knob      = document.getElementById("joystick-knob");

  var maxRadius = 70;

  var rect = container.getBoundingClientRect();
  var centerX = rect.width / 2;
  var centerY = rect.height / 2;
  var isDragging = false;
  var lastSendTime = 0;

  knob.addEventListener("mousedown", startDrag);
  knob.addEventListener("touchstart", startDrag);
  document.addEventListener("mousemove", moveDrag);
  document.addEventListener("touchmove", moveDrag);
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);

  function startDrag(e) {
    isDragging = true;
    e.preventDefault();
  }

  function moveDrag(e) {
    if (!isDragging) return;
    e.preventDefault();

    var clientX = e.touches ? e.touches[0].clientX : e.clientX;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;

    rect = container.getBoundingClientRect();
    var x = clientX - rect.left - centerX;
    var y = clientY - rect.top  - centerY;

    var distance = Math.sqrt(x*x + y*y);
    if (distance > maxRadius) {
      var angle = Math.atan2(y, x);
      x = Math.cos(angle) * maxRadius;
      y = Math.sin(angle) * maxRadius;
    }

    knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;

    var now = Date.now();
    if (now - lastSendTime > 100) {
      var normX = Math.round((x / maxRadius) * 100);
      var normY = Math.round((y / maxRadius) * -100);
      sendJoystick(normX, normY);
      lastSendTime = now;
    }
  }

  function endDrag() {
    isDragging = false;
    knob.style.transform = "translate(-50%, -50%)";
    sendJoystick(0, 0);
  }

  function sendJoystick(x, y) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/joystick?x=" + x + "&y=" + y, true);
    xhr.send();
  }

  function sendGoto() {
    var tx = document.getElementById("tx").value;
    var ty = document.getElementById("ty").value;
    if (tx === "" || ty === "") return;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/goto?x=" + tx + "&y=" + ty, true);
    xhr.send();
  }

  function sendStop() {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/stop", true);
    xhr.send();
  }

  setInterval(function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        var json = JSON.parse(this.responseText);
        document.getElementById("rpm1").innerHTML = json.m1.toFixed(1);
        document.getElementById("rpm2").innerHTML = json.m2.toFixed(1);

        document.getElementById("v1x").innerHTML = json.v1x;
        document.getElementById("v1y").innerHTML = json.v1y;

        document.getElementById("rx").innerHTML  = json.rx.toFixed(1);
        document.getElementById("ry").innerHTML  = json.ry.toFixed(1);
        document.getElementById("th").innerHTML  = json.th.toFixed(1);
      }
    };
    xhr.open("GET", "/data", true);
    xhr.send();
  }, 200);
</script>
</body>
</html>
)rawliteral";

// ===================== ç¼–ç å™¨ä¸­æ–­ =====================
void IRAM_ATTR wheelSpeed_M1() {
  int Lstate = digitalRead(M1_ENCODER_A_PIN);
  if (Lstate != M1_encoder0PinALast) {
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M1_ENCODER) dir = !dir;
    if (dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = Lstate;
}

void IRAM_ATTR wheelSpeed_M2() {
  int Lstate = digitalRead(M2_ENCODER_A_PIN);
  if (Lstate != M2_encoder0PinALast) {
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M2_ENCODER) dir = !dir;
    if (dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = Lstate;
}

// ===================== ç”µæœºé©±åŠ¨ =====================
void set_motor_pwm(int rpwm_pin, int lpwm_pin, int pwm_val) {
  if (pwm_val > 0) {
    ledcWrite(lpwm_pin, 0);
    ledcWrite(rpwm_pin, pwm_val);
  } else {
    ledcWrite(lpwm_pin, abs(pwm_val));
    ledcWrite(rpwm_pin, 0);
  }
}

// ===================== Vive æ›´æ–°ï¼ˆå¸¦æ»¤æ³¢ï¼‰ =====================
void updateVive() {
  if (vive.status() == VIVE_RECEIVING) {
    uint16_t x_raw = vive.xCoord();
    uint16_t y_raw = vive.yCoord();

    bool range_ok = (x_raw > 1000 && x_raw < 8000 &&
                     y_raw > 1000 && y_raw < 8000);

    if (range_ok) {
      bool okx = filterViveValue(x_raw, filterX);
      bool oky = filterViveValue(y_raw, filterY);

      // åªæœ‰å½“ x/y éƒ½æ²¡è¢«åˆ¤å®šä¸ºå¼‚å¸¸å€¼æ—¶ï¼Œæ›´æ–°åæ ‡
      if (okx && oky) {
        vive_x = filterX.median();
        vive_y = filterY.median();
        vive_valid = true;
      }
      // å¦‚æœæ˜¯å¼‚å¸¸å€¼ï¼Œç›´æ¥ä¸¢å¼ƒè¿™å¸§ï¼Œä¿æŒä¸Šä¸€æ¬¡çš„ vive_x/vive_y ä¸å˜
    } else {
      vive_valid = false;
    }
  } else {
    vive_valid = false;
    vive.sync(5);
  }
}

// ===================== Web Handlers =====================
void handleRoot() {
  server.send(200, "text/html; charset=utf-8", index_html);
}

void handleJoystick() {
  if (server.hasArg("x") && server.hasArg("y")) {
    int x = server.arg("x").toInt();
    int y = server.arg("y").toInt();

    // ä¸€æ—¦ç”¨æ‘‡æ†ï¼Œé€€å‡º goto æ¨¡å¼
    goto_active = false;

    float left  = y + x;
    float right = y - x;

    float maxVal = max(abs(left), abs(right));
    if (maxVal > 100) {
      left  = (left  / maxVal) * 100;
      right = (right / maxVal) * 100;
    }

    target_rpm_m1 = (left  / 100.0f) * MAX_SPEED_RPM;
    target_rpm_m2 = (right / 100.0f) * MAX_SPEED_RPM;

    if (x == 0 && y == 0) {
      pid1.reset();
      pid2.reset();
    }

    server.send(200, "text/plain", "OK");
  }
}

void handleGoto() {
  if (server.hasArg("x") && server.hasArg("y")) {
    target_x = server.arg("x").toFloat();
    target_y = server.arg("y").toFloat();
    goto_active = true;
    Serial.print("GOTO SET -> (");
    Serial.print(target_x);
    Serial.print(", ");
    Serial.print(target_y);
    Serial.println(")");
    server.send(200, "text/plain", "GOTO SET");
  } else {
    server.send(400, "text/plain", "Missing x/y");
  }
}

void handleStop() {
  goto_active = false;
  target_rpm_m1 = 0.0f;
  target_rpm_m2 = 0.0f;
  pid1.reset();
  pid2.reset();
  // ç›´æ¥æŠŠ PWM æ¸…é›¶ï¼Œç«‹å³åœ
  set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, 0);
  set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, 0);
  Serial.println("STOP by user.");
  server.send(200, "text/plain", "STOP");
}

void handleData() {
  String json = "{";
  json += "\"m1\":"  + String(current_rpm1);
  json += ",\"m2\":" + String(current_rpm2);
  json += ",\"v1x\":" + String(vive_x);
  json += ",\"v1y\":" + String(vive_y);
  json += ",\"rx\":"  + String(robot_rx, 1);
  json += ",\"ry\":"  + String(robot_ry, 1);
  json += ",\"th\":"  + String(robot_theta_deg, 1);
  json += ",\"valid\":" + String(robot_pose_valid ? 1 : 0);
  json += "}";
  server.send(200, "application/json", json);
}

// ===================== Setup =====================
void setup() {
  Serial.begin(115200);
  delay(100);

  WiFi.softAP(ssid, password);
  Serial.print("AP IP: ");
  Serial.println(WiFi.softAPIP());

  server.on("/",          handleRoot);
  server.on("/joystick",  handleJoystick);
  server.on("/data",      handleData);
  server.on("/goto",      handleGoto);
  server.on("/stop",      handleStop);
  server.begin();

  pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);

  ledcAttach(M1_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M1_LPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_LPWM_PIN, PWM_FREQ, PWM_RES);

  vive.begin();

  Serial.println("------------------------------------");
  Serial.println("Single Vive + Joystick + GOTO (filtered) Init Done.");
  Serial.printf("Vive Pin: %d\n", SIGNALPIN);
  Serial.printf("Filter: window=%d, thr=%.1f\n", WINDOW_SIZE, OUTLIER_THRESHOLD);
  Serial.println("------------------------------------");
}

// ===================== Loop =====================
void loop() {
  server.handleClient();

  unsigned long now = millis();
  static unsigned long last_motor_time = 0;
  static unsigned long last_vive_time  = 0;

  // ------- Vive æ›´æ–°ä¸ä½å§¿ä¼°è®¡ -------
  if (now - last_vive_time >= 50) {
    updateVive();

    if (vive_valid) {
      robot_rx = vive_x;
      robot_ry = vive_y;

      if (!heading_initialized) {
        last_rx = robot_rx;
        last_ry = robot_ry;
        heading_initialized = true;
      } else {
        float dx = robot_rx - last_rx;
        float dy = robot_ry - last_ry;
        float dist_move = sqrtf(dx*dx + dy*dy);
        if (dist_move > 3.0f) {
          float new_heading = atan2f(dy, dx);
          headingRad = 0.6f * headingRad + 0.4f * new_heading;
          last_rx = robot_rx;
          last_ry = robot_ry;
        }
      }

      robot_theta_deg = headingRad * 180.0f / PI;
      robot_pose_valid = true;
    } else {
      robot_pose_valid = false;
    }

    // ä¸²å£çœ‹ä¸€ä¸‹æ»¤æ³¢åçš„åæ ‡
    if (vive_valid) {
      Serial.print("Vive(FILT): (");
      Serial.print(vive_x);
      Serial.print(", ");
      Serial.print(vive_y);
      Serial.print(") | Pose: X=");
      Serial.print(robot_rx, 1);
      Serial.print(", Y=");
      Serial.print(robot_ry, 1);
      Serial.print(", Th=");
      Serial.print(robot_theta_deg, 1);
      Serial.println(" deg");
    } else {
      Serial.println("Vive: Invalid/Lost Tracking.");
    }

    last_vive_time = now;
  }

  // ------- GOTO æ§åˆ¶ -------
  if (goto_active && robot_pose_valid) {
    float dx = target_x - robot_rx;
    float dy = target_y - robot_ry;
    float dist = sqrtf(dx*dx + dy*dy);

    if (dist < GOTO_DIST_EPS) {
      // ======= åˆ°è¾¾ï¼šå…³æ‰è‡ªåŠ¨ï¼Œæ¸…é›¶é€Ÿåº¦å’Œ PWM =======
      goto_active = false;
      target_rpm_m1 = 0.0f;
      target_rpm_m2 = 0.0f;
      pid1.reset();
      pid2.reset();
      set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, 0);
      set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, 0);
      Serial.println("GOTO: Target reached -> STOP.");
    } else {
      float desired_heading = atan2f(dy, dx);
      float err = desired_heading - headingRad;
      while (err >  PI) err -= 2.0f * PI;
      while (err < -PI) err += 2.0f * PI;

      float v;
      if (dist > GOTO_SLOW_DIST) {
        v = MAX_SPEED_RPM;
      } else {
        float ratio = dist / GOTO_SLOW_DIST;
        v = MIN_GOTO_SPEED + (MAX_SPEED_RPM - MIN_GOTO_SPEED) * ratio;
      }

      float omega = KW * err * (MAX_SPEED_RPM / PI);
      float maxOmega = 0.7f * MAX_SPEED_RPM;
      if (omega >  maxOmega) omega =  maxOmega;
      if (omega < -maxOmega) omega = -maxOmega;

      float left_rpm  = v - omega;
      float right_rpm = v + omega;

      left_rpm  = constrain(left_rpm,  -MAX_SPEED_RPM, MAX_SPEED_RPM);
      right_rpm = constrain(right_rpm, -MAX_SPEED_RPM, MAX_SPEED_RPM);

      target_rpm_m1 = left_rpm;
      target_rpm_m2 = right_rpm;
    }
  }

  // ------- ç”µæœº PID æ›´æ–° -------
  if (now - last_motor_time >= (unsigned long)SAMPLE_TIME_MS) {
    float dt = (now - last_motor_time) / 1000.0f;

    noInterrupts();
    long p1 = M1_duration; M1_duration = 0;
    long p2 = M2_duration; M2_duration = 0;
    interrupts();

    current_rpm1 = (p1 / COUNTS_PER_REV) * 60.0f / dt;
    current_rpm2 = (p2 / COUNTS_PER_REV) * 60.0f / dt;

    if (abs(target_rpm_m1) > 0.1f) pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt);
    else pwm1 = 0;

    if (abs(target_rpm_m2) > 0.1f) pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt);
    else pwm2 = 0;

    set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
    set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);

    last_motor_time = now;
  }
}
