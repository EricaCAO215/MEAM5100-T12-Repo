#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <math.h>   
#include "vive510.h"

// ===================== ç”¨æˆ·é…ç½®åŒº =====================
// ç¼–ç å™¨æ–¹å‘é…ç½®
#define INVERT_M1_ENCODER false 
#define INVERT_M2_ENCODER true  

// ğŸš— è½¦ä½“è¿åŠ¨æ–¹å‘é…ç½®ï¼ˆä½ ç°åœ¨æ–¹å‘æ˜¯å¯¹çš„ï¼Œå°±ä¿æŒè¿™æ ·ï¼‰
#define FWD_SIGN  -1   // å‰è¿›æ–¹å‘ï¼š1=ä¿æŒåŸæ¥ï¼Œ-1=å‰åç›¸å
#define TURN_SIGN -1   // è½¬å‘æ–¹å‘ï¼š1=ä¿æŒåŸæ¥ï¼Œ-1=å·¦/å³ç›¸å

const char *ssid = "ESP32_Joystick_Car"; // çƒ­ç‚¹åå­—
const char *password = "12345678";

// ===================== Vive è¿½è¸ªé…ç½® =====================
#define SIGNALPIN1 17   // Vive1
#define SIGNALPIN2 0    // Vive2

Vive510 vive1(SIGNALPIN1);
Vive510 vive2(SIGNALPIN2);

// Vive è¿½è¸ªæ•°æ®
uint16_t vive_x1 = 0, vive_y1 = 0, vive_x2 = 0, vive_y2 = 0;
float thetaDeg = NAN;
bool valid1 = false, valid2 = false;

// ===================== PID å‚æ•° =====================
// æ¯”ä¸Šä¸€ç‰ˆæ¸©æŸ”ä¸€ç‚¹ï¼šKi å‡å°ï¼Œæ•´ä½“æ›´å¥½æ”¶å°¾
float Kp1 = 3.0,  Ki1 = 0.5, Kd1 = 0.05;
float Kp2 = 2.93, Ki2 = 0.5, Kd2 = 0.05;

// é™ä½æœ€å¤§ç›®æ ‡é€Ÿåº¦ (RPM)ï¼Œæ•´ä½“ä¸è¦é‚£ä¹ˆç–¯
const float MAX_SPEED_RPM = 80.0;

// ===================== å…¨å±€å‚æ•° =====================
const float COUNTS_PER_REV = 4480.0;
const int PWM_FREQ = 20000;
const int PWM_RES = 8;
const int SAMPLE_TIME_MS = 100; 

volatile float target_rpm_m1 = 0.0;
volatile float target_rpm_m2 = 0.0;

float current_rpm1 = 0;
float current_rpm2 = 0;
int pwm1 = 0;
int pwm2 = 0;

// æ»¤æ³¢åçš„è½¬é€Ÿ
float filt_rpm1 = 0;
float filt_rpm2 = 0;

// ===================== ç›®æ ‡ç‚¹å¯¼èˆªç›¸å…³ =====================
bool autoGoToGoal = false;   // true æ—¶ï¼Œå°è½¦è‡ªåŠ¨å»ç›®æ ‡ç‚¹
float goal_x = 0.0f;
float goal_y = 0.0f;
// åœè½¦çš„è¯¯å·®é˜ˆå€¼ï¼ˆè¶Šå°åœå¾—è¶Šå‡†ï¼‰
const float POS_TOL = 200.0f;   

// æ˜¯å¦æ¥è¿‘ç›®æ ‡ï¼ˆç”¨äºå…³æ‰â€œæœ€å° PWMâ€ï¼‰
bool near_goal = false;

// ===================== PID ç±»å®šä¹‰ =====================
class SimplePID {
  public:
    float kp, ki, kd;
    float integral = 0;
    float prev_error = 0;
    
    SimplePID(float p, float i, float d) : kp(p), ki(i), kd(d) {}

    int compute(float target, float current, float dt) {
      float error = target - current;
      integral += error * dt;
      integral = constrain(integral, -255.0, 255.0); 
      float derivative = (error - prev_error) / dt;
      prev_error = error;
      float output = (kp * error) + (ki * integral) + (kd * derivative);
      return (int)constrain(output, -255, 255);
    }
    
    void reset() {
      integral = 0;
      prev_error = 0;
    }
};

SimplePID pid1(Kp1, Ki1, Kd1);
SimplePID pid2(Kp2, Ki2, Kd2);

// ===================== ç”µæœºå®šä¹‰ =====================
// M1
const int M1_ENCODER_A_PIN = 7;
const int M1_ENCODER_B_PIN = 3;
const int M1_RPWM_PIN = 33;
const int M1_LPWM_PIN = 38;
volatile long M1_duration = 0;
volatile int M1_encoder0PinALast = LOW;

// M2
const int M2_ENCODER_A_PIN = 18;
const int M2_ENCODER_B_PIN = 14;
const int M2_RPWM_PIN = 6;
const int M2_LPWM_PIN = 5; 
volatile long M2_duration = 0;
volatile int M2_encoder0PinALast = LOW;

WebServer server(80);

// ===================== ç½‘é¡µä»£ç  =====================
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta charset="utf-8">
  <title>ESP32 Joystick & Vive</title>
  <style>
    body { font-family: 'Microsoft YaHei', Arial, sans-serif; text-align: center; margin:0; padding:0; background: #ffffff; color: #333; overflow: hidden; touch-action: none;}
    h2 { margin: 15px 0; font-size: 1.4rem; color: #444; }
    
    #joystick-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px auto;
      background: #f0f0f0;
      border-radius: 50%;
      border: 2px solid #ccc;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
    }
    
    #joystick-knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: #007bff;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      cursor: pointer;
    }
    
    .data-box { 
      display: flex; 
      justify-content: space-around; 
      margin-top: 30px; 
      font-size: 1rem; 
      flex-wrap: wrap;
    }
    .val { font-weight: bold; font-family: monospace; font-size: 1.3rem; }
    
    .lbl-l { color: #d32f2f; }
    .lbl-r { color: #1976d2; }

    .vive-box { 
        margin: 10px 0; 
        width: 100%; 
        font-size: 1rem; 
        padding: 5px 0;
        border-top: 1px solid #eee;
    }
    .vive-coord { font-size: 0.9rem; color: #555; display: inline-block; width: 45%; }
    .vive-angle { font-size: 1.2rem; color: #007bff; margin-top: 5px; }
  </style>
</head>
<body>
  <h2>ğŸ•¹ï¸ è™šæ‹Ÿæ‘‡æ†æ§åˆ¶</h2>
  
  <div id="joystick-container">
    <div id="joystick-knob"></div>
  </div>

  <div class="data-box">
    <div class="lbl-l">å·¦è½® RPM: <span id="rpm1" class="val">0</span></div>
    <div class="lbl-r">å³è½® RPM: <span id="rpm2" class="val">0</span></div>
  </div>

  <div class="vive-box">
    <h3>ğŸ”­ Vive è¿½è¸ªæ•°æ®</h3>
    <div class="vive-coord">
      <span class="lbl-l">V1:</span> x=<span id="x1" class="val">0</span> y=<span id="y1" class="val">0</span>
    </div>
    <div class="vive-coord">
      <span class="lbl-r">V2:</span> x=<span id="x2" class="val">0</span> y=<span id="y2" class="val">0</span>
    </div>
    <div class="vive-angle">
      è§’åº¦ (&theta;): <span id="theta" class="val">NaN</span> deg
    </div>
  </div>

  <div style="margin-top:20px;">
    <h3>ğŸ¯ ç›®æ ‡ç‚¹å¯¼èˆª</h3>
    X: <input id="gx" type="number" style="width:80px;">
    Y: <input id="gy" type="number" style="width:80px;">
    <button onclick="sendGoal()">Go</button>
    <p style="color:#777; font-size:0.8rem;">
      åæ ‡å•ä½å’Œä¸Šé¢çš„ Vive x/y ä¸€æ ·ï¼Œå…ˆçœ‹å½“å‰å€¼å†å¡«ç›®æ ‡
    </p>
  </div>

  <p style="color:#888; font-size:0.9rem; margin-top: 20px;">æ‹–åŠ¨è“çƒæ§åˆ¶æ–¹å‘ï¼Œæ¾æ‰‹åœæ­¢ï¼ˆæ‘‡æ†ä¸€åŠ¨ï¼Œä¼šæ‰“æ–­è‡ªåŠ¨å¯¼èˆªï¼‰</p>

<script>
  var container = document.getElementById("joystick-container");
  var knob = document.getElementById("joystick-knob");
  
  var maxRadius = 70; 
  
  var rect = container.getBoundingClientRect();
  var centerX = rect.width / 2;
  var centerY = rect.height / 2;
  var isDragging = false;
  var lastSendTime = 0;

  knob.addEventListener("mousedown", startDrag);
  knob.addEventListener("touchstart", startDrag);
  document.addEventListener("mousemove", moveDrag);
  document.addEventListener("touchmove", moveDrag);
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("touchend", endDrag);

  function startDrag(e) {
    isDragging = true;
    e.preventDefault();
  }

  function moveDrag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    var clientX = e.touches ? e.touches[0].clientX : e.clientX;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    rect = container.getBoundingClientRect();
    var x = clientX - rect.left - centerX;
    var y = clientY - rect.top - centerY;
    
    var distance = Math.sqrt(x*x + y*y);
    if (distance > maxRadius) {
      var angle = Math.atan2(y, x);
      x = Math.cos(angle) * maxRadius;
      y = Math.sin(angle) * maxRadius;
    }
    
    knob.style.transform = 'translate(calc(-50% + ' + x + 'px), calc(-50% + ' + y + 'px))';
    
    var now = Date.now();
    if (now - lastSendTime > 100) { 
      var normX = Math.round((x / maxRadius) * 100);
      var normY = Math.round((y / maxRadius) * -100); 
      sendJoystick(normX, normY);
      lastSendTime = now;
    }
  }

  function endDrag() {
    isDragging = false;
    knob.style.transform = "translate(-50%, -50%)"; 
    sendJoystick(0, 0); 
  }

  function sendJoystick(x, y) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/joystick?x=" + x + "&y=" + y, true);
    xhr.send();
  }

  function sendGoal() {
    var gx = document.getElementById("gx").value;
    var gy = document.getElementById("gy").value;
    if (gx === "" || gy === "") return;

    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/setgoal?x=" + gx + "&y=" + gy, true);
    xhr.send();
  }

  setInterval(function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        var json = JSON.parse(this.responseText);
        
        document.getElementById("rpm1").innerHTML = json.m1.toFixed(1);
        document.getElementById("rpm2").innerHTML = json.m2.toFixed(1);

        document.getElementById("x1").innerHTML = json.x1;
        document.getElementById("y1").innerHTML = json.y1;
        document.getElementById("x2").innerHTML = json.x2;
        document.getElementById("y2").innerHTML = json.y2;
        
        if (json.theta === "NaN") {
            document.getElementById("theta").innerHTML = "NaN";
        } else {
            document.getElementById("theta").innerHTML = parseFloat(json.theta).toFixed(2);
        }
      }
    };
    xhr.open("GET", "/data", true);
    xhr.send();
  }, 200); 
</script>
</body>
</html>
)rawliteral";

// ===================== Vive æ•°æ®å¤„ç†å‡½æ•° =====================

uint32_t med3filt(uint32_t a, uint32_t b, uint32_t c) {
  uint32_t middle;
  if ((a <= b) && (a <= c))
    middle = (b <= c) ? b : c;
  else if ((b <= a) && (b <= c))
    middle = (a <= c) ? a : c;
  else
    middle = (a <= b) ? a : b;
  return middle;
}

void updateViveData() {
  // Vive1
  if (vive1.status() == VIVE_RECEIVING) {
    static uint16_t x10, y10, oldx11, oldx12, oldy11, oldy12;

    oldx12 = oldx11; oldy12 = oldy11;
    oldx11 = x10;    oldy11 = y10;

    x10 = vive1.xCoord();
    y10 = vive1.yCoord();

    uint16_t new_x = med3filt(x10, oldx11, oldx12);
    uint16_t new_y = med3filt(y10, oldy11, oldy12);

    if (new_x > 8000 || new_y > 8000 || new_x < 1000 || new_y < 1000) {
      vive_x1 = 0; 
      vive_y1 = 0;
      valid1 = false;
    } else {
      valid1 = true;
      vive_x1 = new_x;
      vive_y1 = new_y;
    }

    static uint16_t last_x1 = 0, last_y1 = 0;
    static bool has_last1 = false;
    const int BIG_JUMP = 600;

    if (valid1) {
      if (!has_last1) {
        last_x1 = vive_x1;
        last_y1 = vive_y1;
        has_last1 = true;
      } else {
        int dx = (int)vive_x1 - (int)last_x1;
        int dy = (int)vive_y1 - (int)last_y1;

        if (abs(dx) > BIG_JUMP || abs(dy) > BIG_JUMP) {
          vive_x1 = last_x1;
          vive_y1 = last_y1;
        } else {
          last_x1 = vive_x1;
          last_y1 = vive_y1;
        }
      }
    }
  } else {
    vive_x1 = 0; 
    vive_y1 = 0; 
    valid1 = false;
    vive1.sync(5);
  }
  
  // Vive2
  if (vive2.status() == VIVE_RECEIVING) {
    static uint16_t x20, y20, oldx21, oldx22, oldy21, oldy22;
    oldx22 = oldx21; oldy22 = oldy21;
    oldx21 = x20;    oldy21 = y20;
    
    x20 = vive2.xCoord();
    y20 = vive2.yCoord();
    vive_x2 = med3filt(x20, oldx21, oldx22);
    vive_y2 = med3filt(y20, oldy21, oldy22);

    if (vive_x2 > 8000 || vive_y2 > 8000 || vive_x2 < 1000 || vive_y2 < 1000) {
      vive_x2 = 0; vive_y2 = 0;
      valid2 = false;
    } else {
      valid2 = true;
    }
  } else {
    vive_x2 = 0; vive_y2 = 0; 
    valid2 = false;
    vive2.sync(5);
  }
  
  // å°æŠ–åŠ¨å¿½ç•¥
  const int THRESH = 150;
  static uint16_t fx1 = 0, fy1 = 0, fx2 = 0, fy2 = 0;
  static bool inited1 = false, inited2 = false;

  if (valid1 && vive_x1 != 0 && vive_y1 != 0) {
    if (!inited1) {
      fx1 = vive_x1; fy1 = vive_y1;
      inited1 = true;
    } else {
      if (abs((int)vive_x1 - (int)fx1) < THRESH) vive_x1 = fx1;
      else fx1 = vive_x1;

      if (abs((int)vive_y1 - (int)fy1) < THRESH) vive_y1 = fy1;
      else fy1 = vive_y1;
    }
  } 

  if (valid2 && vive_x2 != 0 && vive_y2 != 0) {
    if (!inited2) {
      fx2 = vive_x2; fy2 = vive_y2;
      inited2 = true;
    } else {
      if (abs((int)vive_x2 - (int)fx2) < THRESH) vive_x2 = fx2;
      else fx2 = vive_x2;

      if (abs((int)vive_y2 - (int)fy2) < THRESH) vive_y2 = fy2;
      else fy2 = vive_y2;
    }
  } 
  
  // è§’åº¦
  thetaDeg = NAN;
  if (valid1 && valid2 && vive_x1 != 0 && vive_y1 != 0 && vive_x2 != 0 && vive_y2 != 0) {
    int32_t dx = (int32_t)vive_x2 - (int32_t)vive_x1;
    int32_t dy = (int32_t)vive_y2 - (int32_t)vive_y1;
    if (dx != 0 || dy != 0) {
      float thetaRad = atan2((float)dy, (float)dx);
      thetaDeg = thetaRad * 180.0f / PI; 
    }
  }
}

// ===================== ç¼–ç å™¨ä¸­æ–­ =====================
void IRAM_ATTR wheelSpeed_M1() {
  int Lstate = digitalRead(M1_ENCODER_A_PIN);
  if(Lstate != M1_encoder0PinALast) {
    int val = digitalRead(M1_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M1_ENCODER) dir = !dir;
    if(dir) M1_duration++; else M1_duration--;
  }
  M1_encoder0PinALast = Lstate;
}

void IRAM_ATTR wheelSpeed_M2() {
  int Lstate = digitalRead(M2_ENCODER_A_PIN);
  if(Lstate != M2_encoder0PinALast) {
    int val = digitalRead(M2_ENCODER_B_PIN);
    bool dir = (val != Lstate);
    if (INVERT_M2_ENCODER) dir = !dir;
    if(dir) M2_duration++; else M2_duration--;
  }
  M2_encoder0PinALast = Lstate;
}

// ===================== ç”µæœºé©±åŠ¨ =====================
void set_motor_pwm(int rpwm_pin, int lpwm_pin, int pwm_val) {
  if (pwm_val > 0) {
    ledcWrite(lpwm_pin, 0);     
    ledcWrite(rpwm_pin, pwm_val);  
  } else {
    ledcWrite(lpwm_pin, abs(pwm_val));      
    ledcWrite(rpwm_pin, 0);  
  }
}

// ===================== Web Handlers =====================
void handleRoot() { 
  server.send(200, "text/html; charset=utf-8", index_html); 
}

void handleJoystick() {
  if (server.hasArg("x") && server.hasArg("y")) {
    autoGoToGoal = false;

    int x = server.arg("x").toInt();  
    int y = server.arg("y").toInt();  
    
    float left = y + x;
    float right = y - x;

    float maxVal = max(abs(left), abs(right));
    if (maxVal > 100) {
      left = (left / maxVal) * 100;
      right = (right / maxVal) * 100;
    }

    target_rpm_m1 = (left / 100.0) * MAX_SPEED_RPM;
    target_rpm_m2 = (right / 100.0) * MAX_SPEED_RPM;

    if (x == 0 && y == 0) {
      pid1.reset();
      pid2.reset();
    }

    server.send(200, "text/plain", "OK");
  }
}

void handleData() {
  String json = "{\"m1\":" + String(current_rpm1, 1) + 
                ",\"m2\":" + String(current_rpm2, 1) + 
                ",\"x1\":" + String(vive_x1) + 
                ",\"y1\":" + String(vive_y1) +
                ",\"x2\":" + String(vive_x2) + 
                ",\"y2\":" + String(vive_y2) +
                ",\"theta\":" + (isnan(thetaDeg) ? "\"NaN\"" : String(thetaDeg, 2)) +
                "}";
  server.send(200, "application/json", json);
}

void handleSetGoal() {
  if (server.hasArg("x") && server.hasArg("y")) {
    goal_x = server.arg("x").toFloat();
    goal_y = server.arg("y").toFloat();

    autoGoToGoal = true;
    pid1.reset();
    pid2.reset();

    Serial.print("New goal: ");
    Serial.print(goal_x); Serial.print(", ");
    Serial.println(goal_y);

    server.send(200, "text/plain", "OK");
  } else {
    server.send(400, "text/plain", "Missing x or y");
  }
}

// ===================== Setup & Loop =====================
void setup() {
  Serial.begin(115200);
  
  WiFi.softAP(ssid, password);
  Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());

  server.on("/", handleRoot);
  server.on("/joystick", handleJoystick);  
  server.on("/data", handleData);
  server.on("/setgoal", handleSetGoal);
  server.begin();

  pinMode(M1_ENCODER_A_PIN, INPUT_PULLUP);  
  pinMode(M1_ENCODER_B_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_A_PIN, INPUT_PULLUP);
  pinMode(M2_ENCODER_B_PIN, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(M1_ENCODER_A_PIN), wheelSpeed_M1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(M2_ENCODER_A_PIN), wheelSpeed_M2, CHANGE);

  ledcAttach(M1_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M1_LPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_RPWM_PIN, PWM_FREQ, PWM_RES);
  ledcAttach(M2_LPWM_PIN, PWM_FREQ, PWM_RES);

  vive1.begin();
  vive2.begin();
  Serial.println("Two Vive trackers started");
}

void loop() {
  server.handleClient();
  updateViveData();

  static unsigned long last_time = 0;
  unsigned long now = millis();
  
  if (now - last_time >= SAMPLE_TIME_MS) {
    float dt = (now - last_time) / 1000.0;  
    
    noInterrupts();
    long p1 = M1_duration; M1_duration = 0;
    long p2 = M2_duration; M2_duration = 0;
    interrupts();

    // ==== åŸå§‹ RPM ====
    float raw_rpm1 = (p1 / COUNTS_PER_REV) * 60.0 / dt;
    float raw_rpm2 = (p2 / COUNTS_PER_REV) * 60.0 / dt;

    // ==== ä½é€šæ»¤æ³¢ï¼Œå¹³æ»‘é€Ÿåº¦ ====
    const float alpha = 0.3f;  // 0~1ï¼Œè¶Šå°è¶Šå¹³æ»‘
    filt_rpm1 = alpha * raw_rpm1 + (1.0f - alpha) * filt_rpm1;
    filt_rpm2 = alpha * raw_rpm2 + (1.0f - alpha) * filt_rpm2;

    current_rpm1 = filt_rpm1;
    current_rpm2 = filt_rpm2;

    // ========= è‡ªåŠ¨å¯¼èˆªï¼šæ ¹æ® Vive åæ ‡å¼€å¾€ç›®æ ‡ç‚¹ =========
    near_goal = false;
    if (autoGoToGoal && valid1 && valid2 && !isnan(thetaDeg)) {
      float rx = 0.5f * (float)vive_x1 + 0.5f * (float)vive_x2;
      float ry = 0.5f * (float)vive_y1 + 0.5f * (float)vive_y2;

      float dx = goal_x - rx;
      float dy = goal_y - ry;

      float dist2 = dx * dx + dy * dy;
      float dist  = sqrtf(dist2);

      if (dist2 < POS_TOL * POS_TOL) {
        // çœŸæ­£åˆ°ç›®æ ‡é™„è¿‘ï¼šåœä¸‹
        target_rpm_m1 = 0;
        target_rpm_m2 = 0;
        near_goal = true;
      } else {
        // ç¦»ç›®æ ‡å¤šè¿œå°±è·‘å¤šå¿«ï¼šè¿œå¤„è·‘å¿«ï¼Œè¿‘å¤„è‡ªåŠ¨å‡é€Ÿ
        float thetaRad = thetaDeg * PI / 180.0f;
        float c = cosf(thetaRad);
        float s = sinf(thetaRad);

        float ex =  c * dx + s * dy;   // å‰å
        float ey = -s * dx + c * dy;   // å·¦å³

        // è·ç¦»å½’ä¸€åŒ–ï¼Œæœ€å¤§ 600 å•ä½æ—¶å…¨é€Ÿï¼Œå°äº 600 æ—¶çº¿æ€§å‡é€Ÿ
        const float DIST_SAT = 600.0f;   // å¯æŒ‰ä½ çš„åœºåœ°å¤§å°è°ƒ
        float gain_scale = dist / DIST_SAT;
        if (gain_scale > 1.0f) gain_scale = 1.0f;
        if (gain_scale < 0.15f) gain_scale = 0.15f; // é€¼è¿‘ç›®æ ‡ä½†ä¸è‡³äºå®Œå…¨æ²¡åŠ›

        // æ›´æ¸©æŸ”ä¸€ç‚¹çš„åŸºç¡€å¢ç›Š
        float k_v = 0.08f;
        float k_w = 0.006f;

        float v_cmd = FWD_SIGN  * k_v * ex * gain_scale;
        float w_cmd = TURN_SIGN * k_w * ey * gain_scale;

        float v_max = MAX_SPEED_RPM * 1.0f;
        if (v_cmd >  v_max) v_cmd =  v_max;
        if (v_cmd < -v_max) v_cmd = -v_max;

        float w_max = MAX_SPEED_RPM * 1.0f;
        if (w_cmd >  w_max) w_cmd =  w_max;
        if (w_cmd < -w_max) w_cmd = -w_max;

        target_rpm_m1 = v_cmd - w_cmd;
        target_rpm_m2 = v_cmd + w_cmd;

        // ç”¨äºåé¢å†³å®šè¦ä¸è¦ç”¨æœ€å° PWM
        if (dist < 2.0f * POS_TOL) {
          near_goal = true;  // éå¸¸é è¿‘æ—¶ï¼Œåˆ«å†çŒ›è¸©æœ€å° PWM
        }
      }
    }
    // ========= è‡ªåŠ¨å¯¼èˆªé€»è¾‘ç»“æŸ =========

    // ==== PID è®¡ç®—ï¼Œä½¿ç”¨å¹³æ»‘åçš„ current_rpm ====
    if (fabsf(target_rpm_m1) > 0.1f) {
      pwm1 = pid1.compute(target_rpm_m1, current_rpm1, dt);
    } else {
      pwm1 = 0;
      pid1.reset();
    }

    if (fabsf(target_rpm_m2) > 0.1f) {
      pwm2 = pid2.compute(target_rpm_m2, current_rpm2, dt);
    } else {
      pwm2 = 0;
      pid2.reset();
    }

    // ==== æœ€å° PWMï¼šåªåœ¨ç¦»ç›®æ ‡æ¯”è¾ƒè¿œçš„æ—¶å€™ç”¨ï¼Œé¿å…è¿‘å¤„åœä¸ä¸‹æ¥ ====
    const int MIN_PWM = 40;  // æ¯”ä¸Šä¸€ç‰ˆå°ä¸€ç‚¹
    if (!near_goal && fabsf(target_rpm_m1) > 1.0f && pwm1 != 0 && abs(pwm1) < MIN_PWM) {
      pwm1 = (pwm1 > 0) ? MIN_PWM : -MIN_PWM;
    }
    if (!near_goal && fabsf(target_rpm_m2) > 1.0f && pwm2 != 0 && abs(pwm2) < MIN_PWM) {
      pwm2 = (pwm2 > 0) ? MIN_PWM : -MIN_PWM;
    }

    set_motor_pwm(M1_RPWM_PIN, M1_LPWM_PIN, pwm1);
    set_motor_pwm(M2_RPWM_PIN, M2_LPWM_PIN, pwm2);

    last_time = now;
  }
}
